

[TOC]


# 数据结构

## 分块

​    在某些情况下，我们可能需要暴力地处理数组的每一个数，数组分块提供了一种简单的优化来降低复杂度，使得原本的$O(n)$降为$O(\sqrt n)$，这可能不是最优解，但一定足够简单（事实上，在1e5范围内，$O(\log^2 n)$和$O(\sqrt n)$差距不大）。
**这类问题的“整体”性质更弱，有时不存在高效的信息合并化简方法，需要在“批量”和“零散”之间找到平衡点。**

> 能够处理的经典问题——区间加 & 区间询问大于 $c$  的元素的个数、区间加 & 区间第 $k$ 小......

**例题** [由乃打扑克](https://www.luogu.com.cn/problem/P5356**)

> 给你一个长为 $n$ 的序列 $a$，需要支持 $m$ 次操作，操作有两种：
1、查询区间 $[l,r]$ 的第 $k$ 小值。
2、区间 $[l,r]$ 加上 $k$。

分块 + 整体二分

第 $k$ 小的值 $x$ 就相当于区间内存在 $k-1$ 个数小于等于 $x$，并且求这个值符合二分的规则，故可以整体二分确定 $x$ 的大小。

几个优化：

1. 二分前将左右两块散块合并，这样可以用$O(log\ B)$来代替对整个散块遍历的$O(B)$。

2. 二分前计算出二分的上下界，以减少二分次数。

复杂度分析：

1. add 时间复杂度 $O(B + n / B)$

2. query 时间复杂度$O(B + (n / B)log\ B\ log\ w)$  , 其中$log\ w$ 是二分是次数，大概为$20-30$

```cpp
int n, m, BS = 900;
ll a[MAXN];
int _1[MAXN], _2[MAXN], t1, t2;
struct BLOCK {
    int l, r;
    ll ex;
    vector<ll> B;
    vector<int> mp;
    BLOCK(int s) {
        B.resize(s);
        ex = 0;
    }
    BLOCK(int _l, int _r) {
        ex = 0;
        l = _l, r = _r;
        int s = r - l + 1;
        B.resize(s);
        mp.resize(s);
        for(int i = l; i <= r; ++ i) {
            mp[i - l] = i;
        }
        sort(mp.begin(), mp.end(), [&] (int x, int y)  {
            return a[x] < a[y];
        });
        for(int i = 0; i < s; i ++) {
            B[i] = a[mp[i]];
        }
    }
    void rebuild(int s, int t, int k) {
        t1 = t2 = 0;
        for(int i = 0; i < mp.size(); ++ i) {
            int x = mp[i];
            if(x >= s && x <= t) _1[t1 ++] = x;
            else _2[t2 ++] = x;
        }
        for(int i = 0; i < t1; ++ i) a[_1[i]] += k;
        int  i = 0, j = 0, c = 0;
        while(i < t1 && j < t2) {
            if(a[_1[i]] < a[_2[j]]) mp[c ++] = _1[i ++];
            else mp[c ++] = _2[j ++];
        }
        while(i < t1) mp[c ++] = _1[i ++];
        while(j < t2) mp[c ++] = _2[j ++];
        for(int i = 0; i < mp.size(); i ++) B[i] = a[mp[i]];
    }
};
vector<BLOCK> block;
inline void add(int l, int r, int k) {
    int lb = l / BS, rb = r / BS;
    if(lb == rb) {
        block[lb].rebuild(l, r, k);
    } else {
        block[lb].rebuild(l, block[lb].r, k);
        block[rb].rebuild(block[rb].l, r, k);
        for(int i = lb + 1; i < rb; i ++) {
            block[i].ex += k;
        }
    }
}
inline ll query(int l, int r, int k) {
    int lb = l / BS, rb = r / BS;
    if(lb == rb) {
        int c = 0;
        for(int i : block[lb].mp) {
            if(i >= l && i <= r) c ++;
            if(c == k) return a[i] + block[lb].ex;
        }
    } else {
        BLOCK _ex(block[lb].r - l + 1 + r - block[rb].l + 1);
        t1 = t2 = 0;
        for(int i : block[lb].mp) {
            if(i >= l) _1[t1 ++] = a[i] + block[lb].ex;
        }
        for(int i : block[rb].mp) {
            if(i <= r) _2[t2 ++] = a[i] + block[rb].ex;
        }
        int c = 0, i = 0, j = 0;
        while(i < t1 && j < t2) {
            if(_1[i] < _2[j]) _ex.B[c ++] = _1[i ++];
            else _ex.B[c ++] = _2[j ++];
        }
        while(i < t1) _ex.B[c ++] = _1[i ++];
        while(j < t2) _ex.B[c ++] = _2[j ++];
        ll L = 1e18, R = -1e18;
        L = min(L, _ex.B[0]);
        R = max(R, _ex.B.back());
        for(int i = lb + 1; i < rb; ++ i) {
            L = min(L, block[i].B[0] + block[i].ex);
            R = max(R, block[i].B.back() + block[i].ex);
        }
        L --, R ++;
        while(R > L + 1) {
            ll M = L + R  >> 1;
            int cnt = 0;
            cnt += lower_bound(_ex.B.begin(), _ex.B.end(), M) - _ex.B.begin();
            for(int i = lb + 1; i < rb; i ++) {
                cnt += lower_bound(block[i].B.begin(), block[i].B.end(), M - block[i].ex) - block[i].B.begin();
            }
            if(cnt >= k) R = M;
            else L = M;
        }
        return R - 1;
    }
}
int main() {
    cin >> n >> m;
    for(int i = 0; i < n; i ++) {
        cin >> a[i];
    }
    for(int i = 0; 1ll * i * BS < n; ++ i) {
        int l = i * BS, r = min(n - 1, (i + 1) * BS - 1);
        block.push_back(BLOCK(l, r));
    }
    while(m --) {
        int op, l, r, k;
        cin >> op >> l >> r >> k;
        l --, r --;
        if(op == 1) {
            if(r - l + 1 < k) {
                cout << "-1\n";
            } else {
                cout << query(l, r, k) << '\n';
            }
        } else {
            add(l, r, k);
        }
    }
}
```

## 线段树

​	线段树是一种维护含幺半群的数据结构（含幺半群就是包含幺元以及满足结合律的代数系统）。线段树上的每一个点都具有相同的性质，可以看作树的叶子是我们最开始所需处理的数据，而每向上一层，数据量减少一半，而所解出的值仍等价于最开始的数据，因此复杂度是$O(log)$。

​	能添加懒标记的线段树在线段树的基础上，还需满足下面几个点：懒标记能与线段树所需维护的量进行运算（后面会看到的mapping），懒标记之间能够进行运算（后面会看到的composition）。

**一般线段树**

如上面所说的，这份板子中的 $e$ 表示幺元，$f$ 表示求值的二元运算。
同时，这份板子中所维护的线段是 $[l, r)$ ，在使用的时候需要注意。

```cpp
template<typename T, typename F>
struct SegmentTree {
    int n;
    const F f;          // 二元运算
    const T e = T();    // 单位元
    vector<T> tree;
    SegmentTree(int n, F f) : n(n), tree(4 << __lg(n)), f(f) {}
    SegmentTree(vector<T> a, F f) : SegmentTree(a.size(), f) {
        function<void(int, int, int)> build = [&](int p, int l, int r) {
            if(r - l == 1) {
                tree[p] = a[l];
                return;
            }
            int m = l + r >> 1;
            build(p << 1, l, m), build(p << 1 | 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    };
    void pull(int p) {
        tree[p] = f(tree[p << 1], tree[p << 1 | 1]);
    }
    void modify(int p, int l, int r, int x, const T& v) {
        if(r - l == 1) {
            tree[p] = v;
            return;
        }
        int m = l + r >> 1;
        if(x < m) modify(p << 1, l, m, x, v);
        else modify(p << 1 | 1, m, r, x, v);
        pull(p);
    }
    T query(int p, int l, int r, int s, int t) {
        if(l >= t || r <= s) {
            return T();
        }
        if(l >= s && r <= t) {
            return tree[p];
        }
        int m = l + r >> 1;
        T res = f(query(p << 1, l, m, s, t), query(p << 1 | 1, m, r, s, t));
        return res;
    }
};
struct node {
    int v;
    node() : v(INF) {}
    node(int v) : v(v) {}
    bool operator<(const node& p) const{
        return v < p.v;
    }
};
auto f = [](node a, node b) {
    return min(a, b); 
};
void solve() {
    int n, q;
    cin >> n >> q;
    SegmentTree<node, decltype(f)> st(n + 1, f);
    while(q --) {
        int op, x, y;
        cin >> op >> x >> y;
        if(op == 0) {
            st.modify(1, 0, n, x, node(y));
        } else {
            cout << st.query(1, 0, n, x, y + 1).v << '\n';
        }
    }
}
```

以上的代码是用来处理区间最小值的，若需要处理区间和，仅需做如下修改。

```cpp
struct node {
    int v;
    node() : v(0) {}
    node(int v) : v(v) {}
};
auto f = [](node a, node b) {
    return node(a.v + b.v); 
};
```

接下来是线段树的一个变式——维护大于 $0$ 的数据个数。代表应用就是扫描线。

下面的代码主要改动的部分就是修改，以及空间开大了一倍。

```cpp
template<typename T, typename F>
struct SegmentTree {
    int n;
    const F f;          // 二元运算
    const T e = T();    // 单位元
    vector<T> tree;
    SegmentTree(int n, F f) : n(n), tree(8 << __lg(n)), f(f) {}
    SegmentTree(vector<T> a, F f) : SegmentTree(a.size(), f) {
        function<void(int, int, int)> build = [&](int p, int l, int r) {
            if(r - l == 1) {
                tree[p] = a[l];
                return;
            }
            int m = l + r >> 1;
            build(p << 1, l, m), build(p << 1 | 1, m, r);
            pull(p, l, r);
        };
        build(1, 0, n);
    };
    void pull(int p, int l, int r) {
        tree[p] = f(tree[p], tree[p << 1], tree[p << 1 | 1], l, r);
    }
    // 每次修改都需要数据 pull 一次进行数据更新
    void modify(int p, int l, int r, int s, int t, const int& v) {
        if(l >= t || r <= s) {
            return;
        }
        if(l >= s && r <= t) {
            tree[p].v += v;
            pull(p, l, r);
            return;
        }
        int m = l + r >> 1;
        modify(p << 1, l, m, s, t, v);
        modify(p << 1 | 1, m, r, s, t, v);
        pull(p, l, r);
    }
    T query(int p, int l, int r, int s, int t) {
        if(l >= t || r <= s) {
            return T();
        }
        if(l >= s && r <= t) {
            return tree[p];
        }
        int m = l + r >> 1;
        T res = f(query(p << 1, l, m, s, t), query(p << 1 | 1, m, r, s, t));
        return res;
    }
};
// 其中 v 是区间上元素的值，len 表示区间上大于 0 的长度。
struct node {
    int v;
    int len;
    node() : v(0), len(0) {}
    node(int v, int len) : v(v), len(len) {}
};
auto f = [](node k, node a, node b, int l, int r) {
    if(r >= Y.size()) r --;
    return node(k.v, k.v ? r - l : a.len + b.len); 
};
```

**添加懒标记的线段树**

```cpp
template<typename T, typename F, typename L, typename Map, typename Com>
struct Lazy_Segtre {
    int n;
    const F f;                  // 二元运算
    const T e  = T();           // 单位元
    const L e1 = L();           // 懒标记单位元
    const Map mapping;          // 解懒标记
    const Com composition;      // 添加(合并)懒标记
    vector<T> tree;
    vector<L> lazy;
    Lazy_Segtre(int n, F f, Map mapping, Com c) : n(n), tree(4 << __lg(n)), lazy(4 << __lg(n)), f(f), mapping(mapping), composition(c) {}
    Lazy_Segtre(vector<T> a, F f, Map m, Com c) : Lazy_Segtre(a.size(), f, m, c) {
        function<void(int, int, int)> build = [&](int p, int l, int r) {
            if(r - l == 1) {
                tree[p] = a[l];
                return;
            }
            int m = l + r >> 1;
            build(p << 1, l, m), build(p << 1 | 1, m, r);
            push_up(p);
        };
        build(1, 0, n);
    };
    void push_up(int p) {
        tree[p] = f(tree[p << 1], tree[p << 1 | 1]);
    }
    void push_down(int p, int l, int r) {
        tree[p] = mapping(tree[p], lazy[p], l, r);
        if(r - l > 1) {
            int m = l + r >> 1;
            lazy[p << 1] = composition(lazy[p << 1], lazy[p]);
            lazy[p << 1 | 1] = composition(lazy[p << 1 | 1], lazy[p]);
        }
        lazy[p] = e1;
    }
    void modify(int p, int l, int r, int s, int t, const L v) {
        push_down(p, l, r);
        if(l >= t || r <= s) {
            return;
        } 
        if(l >= s && r <= t) {
            lazy[p] = v;
            push_down(p, l, r);
            return;
        }
        int m = l + r >> 1;
        modify(p << 1, l, m, s, t, v);
        modify(p << 1 | 1, m, r, s, t, v);
        push_up(p);
    }
    T query(int p, int l, int r, int s, int t) {
        push_down(p, l, r);
        if(l >= t || r <= s) {
            return e;
        }
        if(l >= s && r <= t) {
            return tree[p];
        }
        int m = l + r >> 1;
        T res = f(query(p << 1, l, m, s, t), query(p << 1 | 1, m, r, s, t));
        return res;
    }
};
struct node {
    i64 v;
    node() : v(0) {}
    node(i64 v) : v(v) {}
    node& operator+= (const node& p) {
        v += p.v;
        return *this;
    }
};
struct Lazy : node {
    Lazy() : node() {}
    Lazy(int v) : node(v) {}
};
auto f = [&](node a, node b) {
    return node(a.v + b.v);
};
auto Map = [&](node a, Lazy b, int l, int r) {
    return node((r - l) * b.v + a.v);
};
auto Com = [&](Lazy a, Lazy b) {
    return Lazy(a.v + b.v);
};
void solve() {
    int n, q;
    cin >> n >> q;
    Lazy_Segtre<node, decltype(f), Lazy, decltype(Map), decltype(Com)> st(n, f, Map, Com);
    while(q --) {
        int op, x, y, z;
        cin >> op >> x >> y;
        x --, y --;
        if(op == 0) {
            cin >> z;
            st.modify(1, 0, n, x, y + 1, Lazy(z));
        } else {
            cout << st.query(1, 0, n, x, y + 1).v << '\n';
        }
    }
}
```

以上代码是区间加和求区间和，区间修改以及RMQ都是大同小异。

下面是区间修改，区间求和的所需做的修改。

```cpp
struct node {
    i64 v;
    node() : v(0) {}
    node(i64 v) : v(v) {}
};
struct Lazy : node {
    bool used;
    Lazy() : node(), used(false) {}
    Lazy(int v) : node(v), used(true) {}
};
auto f = [&](node a, node b) {
    return node(a.v + b.v);
};
auto Map = [&](node a, Lazy b, int l, int r) -> node {
    return node((b.used ? b.v * (r - l) : a.v));
};
auto Com = [&](Lazy a, Lazy b) {
    return (b.used ? b : a);
};
```

## 可持久化线段树

一个用指针实现的板子，可能会比较慢。

```cpp
const int MAXN = 5e5 + 10;
int n, q, cnt;
int a[MAXN], b[MAXN];
struct Node {
    int v;
    Node *lch, *rch;
    Node(int x, Node *a, Node *b) : v(x), lch(a), rch(b) {}
    Node() {}
} tre[MAXN * 30];
Node *root[MAXN];
Node *new_node(int v, Node *a, Node *b) {
    tre[cnt] = Node(v, a, b);
    return &tre[cnt ++];
}
Node *build(int l, int r) {
    if(l == r) {
        Node *cur = new_node(0, 0, 0);
        return cur;
    }
    int m = l + r >> 1;
    Node *cur = new_node(0, 0, 0);
    cur -> lch = build(l, m);
    cur -> rch = build(m + 1, r);
    return cur;
}
Node *modify(int l, int r, int x, Node *cur) {
    if(l == r) {
        Node *a = new_node(cur -> v + 1, 0, 0);
        return a;
    }
    Node *a = new_node(0, cur -> lch, cur -> rch);
    int m = l + r >> 1;
    if(x <= m) {
        a -> lch = modify(l, m, x, a -> lch);
    } else {
        a -> rch = modify(m + 1, r, x, a -> rch);
    }
    a -> v = a -> lch -> v + a -> rch -> v;
    return a;
}
int query(int l, int r, int w, Node *cur1, Node *cur2) {
    if(l == r) {
        if(cur2 -> v - cur1 -> v > w) {
            return l;
        } else {
            return 0;
        }
    }
    int m = l + r >> 1;
    int c = cur2 -> lch -> v - cur1 -> lch -> v;
    if(c > w) {
        return query(l, m, w, cur1 -> lch, cur2 -> lch);
    } else {
        return query(m + 1, r, w, cur1 -> rch, cur2 -> rch);
    }
}
```

## 树链剖分

简单来说就是将树上的信息，通过 $DFS$ 序转化为区间上的信息。

两类经典的树剖操作：与路径相关、与子树相关。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> PII;
const int INF = 1e9 + 7, MAXN = 1e5 + 10, mod = 998244353;
int N = 1e5 + 7;
int n, m, p, r;
vector<int> tre[MAXN];
int fa[MAXN], siz[MAXN], hson[MAXN], dfn[MAXN], dep[MAXN], top[MAXN], rnk[MAXN], tim;
ll d[MAXN << 2], v[MAXN << 2], a[MAXN];
// seg tre
void add(int k, int l, int r, int s, int t, int z) {
    if(l == s && r == t) {
        v[k] += z;
        return;
    }
    d[k] += (t - s + 1) * z;
    int m = l + r >> 1;
    if(m >= t) {
        add(k << 1, l, m, s, t, z);
    } else if(m < s) {
        add(k << 1 | 1, m + 1, r, s, t, z);
    } else {
        add(k << 1, l, m, s, m, z);
        add(k << 1 | 1, m + 1, r, m + 1, t, z); 
    }
}
ll ask(int k, int l, int r, int s, int t, ll z) {
    z += v[k];
    if(l == s && r == t) {
        return (t - s + 1) * z + d[k] ;
    }
    int m = l + r >> 1;
    if(m >= t) {
        return ask(k << 1, l, m, s, t, z) ;
    } else if(s > m) {
        return ask(k << 1 | 1, m + 1, r, s, t, z) ;
    } else {
        return ask(k << 1, l, m, s, m, z) +
               ask(k << 1 | 1, m + 1, r, m + 1, t, z) ;
    }
}
// 树链剖分
void dfs1(int r, int f) {
    siz[r] = 1;
    fa[r] = f;
    dep[r] = dep[f] + 1;
    hson[r] = -1;
    int maxsiz = -1;
    for(auto v : tre[r]) if(f != v) {
        dfs1(v, r);
        siz[r] += siz[v];
        if(siz[v] > maxsiz) {
            hson[r] = v;
            maxsiz = siz[v];
        }
    }
}
void dfs2(int r, int topf) {
    dfn[r] = ++ tim;
    rnk[tim] = r;
    add(1, 1, N, tim, tim, a[r]);
    top[r] = topf;
    if(hson[r] == -1) return ;
    dfs2(hson[r], topf);
    for(auto v : tre[r]) if(v != fa[r] && v != hson[r]) {
        dfs2(v, v);
    }
}
// 树上两点最短路径上的点加 z
void op1(int x, int y, ll z) {
    if(top[x] == top[y]) {
        if(dep[x] > dep[y]) swap(x, y);
        add(1, 1, N, dfn[x], dfn[y], z);
    } else {
        if(dep[top[x]] < dep[top[y]]) swap(x, y);
        add(1, 1, N, dfn[top[x]], dfn[x], z);
        op1(fa[top[x]], y, z);
    }
}
// 树上两点最短路径上的和
ll op2(int x, int y) {
    ll res = 0;
    if(top[x] == top[y]) {
        if(dep[x] > dep[y]) swap(x, y);
        (res += ask(1, 1, N, dfn[x], dfn[y], 0)) ;
    } else {
        if(dep[top[x]] < dep[top[y]]) swap(x, y);
        res += ask(1, 1, N, dfn[top[x]], dfn[x], 0) +
               op2(fa[top[x]], y) ;
    }
    return res;
}
// 树上一点x的子树加z
void op3(int x, int z) {
    add(1, 1, N, dfn[x], dfn[x] + siz[x] - 1, z);
}
// 树上一点子树的和
ll op4(int x) {
    return ask(1, 1, N, dfn[x], dfn[x] + siz[x] - 1, 0);
}
```

## 莫队

​    对于序列上的查询问题, 如果 $[l, r]$ 的答案可以$O(1)$扩展到$[l - 1, r], [l + 1, r], [l, r - 1], [l, r + 1]$，那么对于所有询问，离线处理后可以在 $n\sqrt{q}$ 的时间内找到所有问题的答案。

莫队擅长处理的问题是这么一类问题：区间 $[l, r]$ 中有多少个二元组 $(i, j)$ 满足条件，常规的做法是将区间子区间问题通过前缀和差分的形式转会为区间二元组的问题，**这个技巧会经常用到**。

**具体实现：**

1. 对于区间 $[l,r]$，以 $l$ 所在块的编号为第一关键字升序， $r$ 为第二关键字排序升序。

2. 优化：若 $l$ 所在块编号为奇数, 则按 $r$ 为第二关键字升序，反正则按降序。

3. 具体实现见例题，主要是编写 $O(1)$ 扩展部分的代码。

**例题** [XOR and Favorite Number](https://codeforces.com/problemset/problem/617/E)

**题目大意**

$q$ 次询问，每次询问 $[l, r]$ 求有其中有多少个子区间满足区间异或和为 $k$ 。

由于是子区间问题，所以应该需要将此题中的子区间问题化简成为区间二元组的问题，可以通过做前缀和来做此题。

对原数组进行一次前缀异或和操作（新数组记为$s$），那么可以想到满足条件的二元组为

$$
    s_r \bigoplus s_{l - 1} = k
$$

维护一个桶记录 $s_i \bigoplus k$ 的数量就可以用莫队解决这个问题。

**参考代码**

```cpp
struct qry {
      int l, r, id;
  };
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
int a[MAXN], s[MAXN << 4], cnt[MAXN << 4];
void solve() {
    int n, k, m;
    cin >> n >> m >> k;
    for(int i = 1; i <= n; i ++) {
        cin >> a[i];
        s[i] = s[i - 1] ^ a[i];
    }
    vector<qry> q(m);
    for(int i = 0; i < m; i ++) {
        cin >> q[i].l >> q[i].r;
        q[i].id = i;
    }
    int B = sqrt(n);
    sort(q.begin(), q.end(), [&](qry a, qry b) {
        int xa = a.l / B, xb = b.l / B;
        if(xa != xb) return xa < xb;
        int ya = a.r / B , yb = b.r / B;
        if(xa & 1) {
            return ya > yb;
        } else {
            return ya < yb;
        }
    });
    vector<ll> res(m);
    int lt = 0, rt = -1;
    ll w = 0;
    for(const auto &[l, r, id] : q) {
        while(rt < r) {
            rt ++;
            int x = s[rt];
            w += cnt[x];
            cnt[x ^ k] ++;
        }
        while(rt > r) {
            int x = s[rt];
            cnt[x ^ k] --;
            w -= cnt[x];
            rt --;
        }
        while(lt > l - 1) {
            lt --;
            int x = s[lt];
            w += cnt[x];
            cnt[x ^ k] ++;
        }
        while(lt < l - 1) {
            int x = s[lt];
            cnt[x ^ k] --;
            w -= cnt[x];
            lt ++;
        }
        res[id] = w;
    }
    for(auto i : res) {
        cout << i << "\n";
    }
}
```

[一个简单的询问](https://www.luogu.com.cn/problem/P5268)

**题目大意**

$q$ 次询问，每次询问 $(l_1, r_1, l_2, r_2)$ ，求 $\sum_{x} get(l_1, r_1, x) \times get(l_2, r_2, x)$，其中 $get(l, r, x)$ 表示的区间 $[l, r]$ 中$x$ 出现的次数。

莫队是处理区间二元组的一种手法，而此题中的询问有 $4$ 个参数，我们希望能够通过一些手段转化这个问题。

差分是莫队常见的降低参数个数的手法，将 $get(l, r, x)$ 做一次差分实际上就转化为了 $get(1, r, x) - get(1, l - 1, x)$。

这样原问题就可以化简为
$$
    \sum_{x} get(1, r_1, x)get(1, r_2, x) - get(1, r_1, x)get(1, l_2 - 1, x) + get(1, l_1 - 1, x) get(1, l2 - 1, x) - get(1, l_1 - 1, x)get(1, r_2, x)
$$

经此化简，我们将原题转化为了四个不相关的莫队进行求解。

**参考代码**
```cpp
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
struct qry {
    int l, r, id;
};
int a[MAXN], n, m;
void solve() {
    cin >> n;
    for(int i = 1; i <= n; i ++) {
        cin >> a[i];
    }
    cin >> m;
    vector<vector<qry>> q(4, vector<qry> (m));
    for(int i = 0; i < m; i ++) {
        int l1, r1, l2, r2;
        cin >> l1 >> r1 >> l2 >> r2;
        q[0][i].l = r1, q[0][i].r = r2, q[0][i].id = i;
        q[1][i].l = r1, q[1][i].r = l2 - 1, q[1][i].id = i;
        q[2][i].l = l1 - 1, q[2][i].r = l2 - 1, q[2][i].id = i;
        q[3][i].l = l1 - 1, q[3][i].r = r2, q[3][i].id = i;
        for(int j = 0; j < 4; j ++) {
            if(q[j][i].l > q[j][i].r) {
                swap(q[j][i].l, q[j][i].r);
            }
        }
    }
    int B = sqrt(n);
    vector<ll> res(m);
    for(int i = 0; i < 4; i ++) {
        sort(q[i].begin(), q[i].end(), [&](qry a, qry b) {
            int xa = a.l / B, xb = b.l / B;
            if(xa != xb) return xa < xb;
            int ya = a.r / B , yb = b.r / B;
            if(xa & 1) {
                return ya > yb;
            } else {
                return ya < yb;
            }
        });
        ll w = 0;
        int lt = 0, rt = 0;
        vector<int> cnt1(n + 1), cnt2(n + 1);
        for(const auto &[l, r, id] : q[i]) {
            while(rt < r) {
                rt ++;
                int x = a[rt];
                w -= 1ll * cnt1[x] * cnt2[x];
                cnt2[x] ++;
                w += 1ll * cnt1[x] * cnt2[x];
            }
            while(rt > r) {
                int x = a[rt];
                w -= 1ll * cnt1[x] * cnt2[x];
                cnt2[x] --;
                w += 1ll * cnt1[x] * cnt2[x];
                rt --;
            }
            while(lt < l) {
                lt ++;
                int x = a[lt];
                w -= 1ll * cnt1[x] * cnt2[x];
                cnt1[x] ++;
                w += 1ll * cnt1[x] * cnt2[x];
            }
            while(lt > l) {
                int x = a[lt];
                w -= 1ll * cnt1[x] * cnt2[x];
                cnt1[x] --;
                w += 1ll * cnt1[x] * cnt2[x];
                lt --;
            }
            if(i & 1) {
                res[id] -= w;
            } else {
                res[id] += w;
            }
        }
    }
    for(auto i : res) {
        cout << i << "\n";
    }
}
```

## 树状数组

- 一维：单点修改，区间查询

```cpp
struct BIT {
	int N;
	vector<ll> p;
	BIT(int n) : N (n) {
		p.resize(n + 1);
	}
	void add(int x, int d) {
		for(; x <= N; x += x & -x) {
			p[x] += d;
		}
	}
	ll ask(int x) {
		ll res = 0;
		for(; x; x -= x & -x) {
			res += p[x];
		}
		return res;
	}
	ll ask(int l, int r) {
		return ask(r) - ask(l - 1);
	}
};
```

- 二维 ：区间修改 + 区间查询

维护 $p[i][j], p[i][j] * i, p[i][j] * j, p[i][j] * i * j$

区间和为
$$
(x + 1) * (y + 1) * \sum_{i = 1}^{x}\sum_{j = 1}^{y}p[i][j]
\\-(y + 1) * \sum_{i = 1}^{x}\sum_{j = 1}^{y}p[i][j] * i
\\-(x + 1) * \sum_{i = 1}^{x}\sum_{j = 1}^{y}p[i][j] * j
\\+\sum_{i = 1}^{x}\sum_{j = 1}^{y}p[i][j] *i * j
$$

```cpp
struct dBIT {
    int N, M;
    vector<vector<ll>> p[4];
    dBIT (int n, int m) : N(n), M(m) {
        for(int i = 0; i < 4; i ++) {
            p[i].resize(n + 1, vector<ll> (m + 1));
        }
    }
    void add(int x, int y, int d) {
        for(int i = x; i <= N; i += i & - i) {
            for(int j = y; j <= M; j += j & -j) {
                p[0][i][j] += 1ll * d * x * y;
                p[1][i][j] += 1ll * d * x;
                p[2][i][j] += 1ll * d * y;
                p[3][i][j] += 1ll * d;
            }
        }
    }
    void add(int a, int b, int c, int d, int x) {
        add(a, b, x);
        add(a, d + 1, -x);
        add(c + 1, b, -x);
        add(c + 1, d + 1, x);
    }
    ll ask(int x, int y) {
        ll res = 0;
        for(int i = x; i; i -= i & -i) {
            for(int j = y; j; j -= j & -j) {
                res += p[0][i][j] - (y + 1) * p[1][i][j] - (x + 1) * p[2][i][j] + (x + 1) * (y + 1) * p[3][i][j];
            }
        }
        return res;
    }
    ll ask(int a, int b, int c, int d) {
        return ask(a - 1, b - 1) - ask(a - 1, d) - ask(c, b - 1) + ask(c, d);
    }
};
```

## 平衡树 (Splay)

```cpp
int root, tot;
const int MAXN = 1e5 + 10;
struct ND {
    int ch[2],  // 儿子
        f,      // 父亲
        siz,    // 子树大小
        val,    // 值
        cnt;    // 个数
} nd[MAXN];
void update(int x) {
    nd[x].siz = nd[nd[x].ch[0]].siz + nd[nd[x].ch[1]].siz + nd[x].cnt;
}
void rotate(int x) {
    int y = nd[x].f;
    int z = nd[y].f;
    int k = nd[y].ch[1] == x;
    nd[z].ch[nd[z].ch[1] == y] = x;
    nd[x].f = z;
    nd[y].ch[k] = nd[x].ch[k ^ 1];
    nd[nd[x].ch[k ^ 1]].f = y;
    nd[x].ch[k ^ 1] = y;
    nd[y].f = x;
    update(y), update(x);
}
void splay(int x, int goal) {
    while(nd[x].f != goal) {
        int y = nd[x].f;
        int z = nd[y].f;
        if(z != goal) {
            (nd[z].ch[1] == y) == (nd[y].ch[1] == x) ?
                rotate(y) : rotate(x);
        }
        rotate(x);
    }
    if(goal == 0) {
        root = x;
    }
}
void find(int x) {
    int u = root;
    if(!u) {
        return;
    }
    while(nd[u].ch[x > nd[u].val] && x != nd[u].val) {
        u = nd[u].ch[x > nd[u].val];
    }
    splay(u, 0);
}
void insert(int x) {
    int u = root, f = 0;
    while(u && nd[u].val != x) {
        f = u;
        u = nd[u].ch[x > nd[u].val];
    }
    if(u) {
        nd[u].cnt ++;
    } else {
        u = ++ tot;
        if(f) {
            nd[f].ch[x > nd[f].val] = u;
        }
        nd[u].ch[0] = nd[u].ch[1] = 0;
        nd[u].f = f;
        nd[u].val = x;
        nd[u].cnt = 1;
        nd[u].siz = 1;
    }
    splay(u, 0);
}
// 后继
int Next(int x) {
    find(x);
    int u = root;
    if(nd[u].val > x) return u;
    u = nd[u].ch[1];
    while(nd[u].ch[0]) u = nd[u].ch[0];
    return u;
}
// 前驱
int Pre(int x) {
    find(x);
    int u = root;
    if(nd[u].val < x) return u;
    u = nd[u].ch[0];
    while(nd[u].ch[1]) u = nd[u].ch[1];
    return u;
}
// 删除
void del(int x) {
    int pre = Pre(x), next = Next(x);
    splay(pre, 0), splay(next, pre);
    int del = nd[next].ch[0];
    if(nd[del].cnt > 1) {
        nd[del].cnt --;
        splay(del, 0);
    } else {
        nd[next].ch[0] = 0;
    }
}
// 第 k 大数
int kth(int k) {
    int u = root;
    if(nd[u].siz < k) {
        return 0;
    }
    while(1) {
        int y = nd[u].ch[0];
        if(k > nd[y].siz + nd[u].cnt) {
            k -= nd[y].siz + nd[u].cnt;
            u = nd[u].ch[1];
        } else {
            if(k <= nd[y].siz) {
                u = y;
            } else {
                return nd[u].val;
            }
        }
    }
}
void init() {
    insert(INF), insert(-INF);
}
```

## ST 表

查询区间$[l,r]$看作$max([l,l + 2 ^ p],[r - 2 ^ p,r])$其中$p = {log_{2}{\lfloor r - l + 1\rfloor}}$就可以满足整个区间为$[l,r]$。

```cpp
struct ST {
    vector<vector<int>> st;
    ST(vector<int> a) {
        int n = a.size();
        st.resize(n, vector<int>(log2(n) + 1));
        for(int i = 0; i < n; i ++) {
            st[i][0] = a[i];
        }
        for(int j = 1; j <= log2(n); j ++) {
            for(int i = 0; i + (1 << j) - 1 < n; i ++) {
                st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
};
```

# 图论

## Kruskal 重构树

过程: 按照 $Kruskal$ 最小生成树的加边顺序，对于边 $e(a, b)$，边权为 $c$，令 $x=fa_a,y=fa_b$。若$x \neq y$，则新建一个点 $z$，使得$fa_x=z,fa_y=z,val_z=c$。

性质:

1. 叶子节点均为原先的点，非叶节点为原先的边。
2. 重构树是一个总结点数为$2n-1$的二叉树，但不是满二叉树，最坏情况仍有长度为 $n$ 的链。
3. 重构树是一个大根堆-最小生成树(小根堆-最大生成树)。
4. 在最小生成树中， 原图中任意两点的最短路径中的最大边为重构树中这两点的 lca. 最大生成树相反。

该重构树记录了整个 $Kruskal$ 的过程，可以求子图（子树）相关的一些问题，利用倍增也能够在 $log$ 复杂度内进行 dp 转移的计算。

**例题**

[2021 ICPC 上海 TLife is a Gam](https://codeforces.com/gym/103446/problem/H)

**题目大意：** 给定一张 $n$ 个点 $m$ 条边的无向连通图，每个点拥有点权 $a$, 每条边拥有边权 $w$. 有 $q$ 次询问，每次询问给定初始点 $x$ 和初始能力值 $k$，从 $x$ 点出发，可以通过小于等于当前能力值的边到达另一个点，每次到达一个未经过的点便获得这个点的点权，求最大的能力值。

```cpp
struct EDGE {
    int u, v, w;
    bool operator< (const EDGE &a) const {
        return w < a.w;
    };
};
struct DSU {
    int N;
    vector<int> p;
    DSU(int n) {
        N = n;
        p.resize(n);
        for(int i = 0; i < n; i ++) {
            p[i] = i;
        }
    }
    int root(int x) {
        return p[x] == x ? x : p[x] = root(p[x]);
    }
    bool merge(int x, int y) {
        int X = root(x), Y = root(y);
        if(X == Y) return 1;
        p[X] = Y;
        return 0;
    }
};
struct NODE {
    int f = -1, w = 0;
    ll add = 0;
};
NODE nd[MAXN << 1];
vector<EDGE> e;
ll bz[MAXN << 1][17];
int fa[MAXN << 1][17];
int n, m, q;
int main () {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> m >> q;
    e.resize(m);
    vector<int> a(n);
    for(int i = 0; i < n; i ++) {
        cin >> a[i];
        nd[i].add = a[i];
    }
    for(auto &[u, v, w] : e) {
        cin >> u >> v >> w;
        u --, v --;
    }
    sort(e.begin(), e.end());
    DSU dsu(2 * n + 10);
    for(auto &[u, v, w] : e) {
        int U = dsu.root(u), V = dsu.root(v);
        if(U != V) {
            dsu.merge(U, n), dsu.merge(V, n);
            nd[U].f = nd[V].f = n;
            nd[n].add = nd[U].add + nd[V].add;
            nd[n].w = w;
            n ++;
        }
    }
    for(int i = 0; i < n; i ++) {
        fa[i][0] = nd[i].f;
        bz[i][0] = nd[nd[i].f].w - nd[i].add;
    }
    for(int i = 1; i < 17; i ++) {
        for(int j = 0; j < n; j ++) {
            if(fa[j][i - 1] == - 1) {
                fa[j][i] = -1;
                continue;
            }
            fa[j][i] = fa[fa[j][i - 1]][i - 1];
            bz[j][i] = max(bz[j][i - 1], bz[fa[j][i - 1]][i - 1]);
        }
    }
    while(q --) {
        int x, k;
        cin >> x >> k;
        x --;
        for(int i = 16; i >= 0; i --) {
            if(fa[x][i] != -1) {
                if(bz[x][i] <= k) {
                    x = fa[x][i];
                }
            }
        }
        ll res = k + nd[x].add;
        cout << res << '\n';
    }
}
```

## Floyd

做法中定义了一个数组 `f[k][x][y]` ，表示在子图 $V_k' = \lbrace 1,2,3,...,k\rbrace$ 上 $x, y$ 间的最短路。

在最外层的 $for$ 中枚举所有边就可以处理图上最小环相关的问题。

```cpp
void floyd() {
    dis.resize(n, vector<int>(n), 0x3f3f3f3f);
    for(int i = 0; i < m; i ++) {
        int v, u, w;
        cin >> v >> u >> w;
        dis[v][u] = min(dis[v][u], w);
    }
    for(int i = 0; i < n; i ++) {
        dis[i][i] = 0;
    }
     for(int k = 0; k < n; k ++) {
        for(int i = 0;i < n; i ++) {
            for(in j = 0; j < n; j ++) {
                dis[i][j] = min(dis[i][j], dis[k][j] + dis[i][k]);
            }
        }
        /*
        for(auto edg : Edge) { Todo }
        */
    }   
}
```

## 最短路 Dijkstra

```cpp
vector<vector<PII>> adj;
vector<int> dis;
//vector<int> path;
int n, m;
void Dij(int n, int s) {
    dis.resize(n + 1,0x3f3f3f3f);
    //path.resize(n + 1, 0);
    //int pre = 0;
    dis[s] = 0;
    vector<bool> vis(n + 1);
    priority_queue<PII, vector<PII>, greater<PII>> q;
    q.push({0, s});
    while(!q.empty()) {
        PII u = q.top();
        q.pop();
        int tmpdis = u.first, tmpu = u.second;
        if(vis[tmpu]) continue;
        vis[tmpu] = 1;
        for(auto it : adj[tmpu]) {
            int v = it.first, w = it.second;
            if(dis[v] > dis[tmpu] + w) {
                dis[v] = dis[tmpu] + w;
                q.push({dis[v], v});
                //path[v] = pre;
            }
        }
    }
}
```

## 差分约束 & SPFA

- SPFA

最坏时间复杂度仍为 $O(nm)$。

```cpp
bool spfa(int n, int s) {
    dis.resize(n + 1, 0x3f3f3f3f);
    dis[s] = 0;
    queue<int> q;
    vector<int> vis(n + 1, 0), cnt(n + 1, 0);
    for(int i = 0; i <= n ; i ++) {
		q.push(i);
        vis[i] = 1;
    }
    while(!q.empty()) {
        int v = q.front();
        q.pop();
        vis[v] = 0;
        for(auto it : e[v]) {
            int u = it.first, w = it.second;
            if(dis[u] > dis[v] + w ) {
                dis[u] = dis[v] + w;
                cnt[u] ++;
                if(cnt[u] >= n) {
                    return true;
                }
                if(!vis[u]) {
                    q.push({u});
                	vis[u] = 1;
                }
            }
        }
    }
	return false;
}
```

- 差分约束

差分约束系统是 $n$ 元一次不等式组。建立一个超级源点，该点向其余点连一条边，用来设置初值以及保证求出的解具有一定的性质。

对于一个不等式 $x_u \leq x_v + w$，可以建一条 $e(v \rightarrow u, w)$ 的边，以小于等于号建出的图可以求$x_i \leq x_{s_0}$ 的最大解；同理，将上述不等式转化后 $x_u \geq x_v + w$，可以建一条 $e(v \rightarrow u, w)$ 的边，求$x_i \geq x_{s_0}$ 的最小解。

## 最近公共祖先

树上倍增，$fa[i][j]$表示第节点$i$的第$2^j$个祖先

```cpp
const int MAXN = 2e5 + 10;
int dep[MAXN], fa[MAXN][20], n;
vector<int> e[MAXN];
void dfs(int u, int p) {
    dep[u] = dep[p] + 1;
    fa[u][0] = p;
    for(int v : e[u]) if(v != p) {
        dfs(v, u);
    }
}
void init() {
    dfs(0, 0);
    for(int i = 1; i <= 17; i ++) {
        for(int j = 0; j < n; j ++) {
            fa[j][i] = fa[fa[j][i - 1]][i - 1];
        }
    }
}
int lca(int u, int v) {
    if(dep[u] < dep[v]) {
        swap(u, v);
    }
    int temp = dep[u] - dep[v];
    for(int i = 0; temp; temp >>= 1, i ++) {
        if(temp & 1) {  
            u = fa[u][i];
        }
    }
    if(u == v) return u;
    for(int i = 17; i >= 0; i --) {
        if(fa[u][i] != fa[v][i]) {
            u = fa[u][i], v = fa[v][i];
        }
    }
    return fa[u][0];
}
int dis(int u, int v) {
    return dep[u] + dep[v] - 2 * dep[lca(u, v)];
}
```

## 强连通分量 Tarjan

在有向图中，若对于任意的两个点能够互相到达，则称该图为强连通图。如一张图中存在一个极大子图为强连通图，那么称该子图为原图的一个强连通分量。

```cpp
const int MAXN = 1e4 + 10;
int n, m;
struct Edge {
    int v;
    bool is_bri; //是否为割边（割边：删去这条边后导致整张图的联通分量增大）
};
vector<Edge> e[MAXN];
int dfn[MAXN], low[MAXN], tim = 0;
bool vis[MAXN];
stack<int> stk;
int tag;                                        // 强连通分量个数
vector<int> tar[MAXN];                          // 每个强连通分量的点集
int scc[MAXN];                                  // 每个点属于哪个强连通分量
int deg[MAXN];                                  // 缩点后新图每个点的出度
vector<int> che[MAXN];                          // 缩点后的图
void tarjan(int u) {
    dfn[u] = low[u] = ++ tim;
    vis[u] = 1;
    stk.push(u);
    for(auto &[v, yes] : e[u]) {
        if(!dfn[v]) {                           // 父子边
            tarjan(v, u);
            low[u] = min(low[u], low[v]);       // 更新low
            if(dfn[u] < low[v]) {               // v不能通过u到达更早的祖宗，则为桥
                yes = 1;
            }
        } else if(vis[v]) {						// 未确定强连通分量的点
            low[u] = min(low[u], dfn[v]);	    // 一次返祖最远到达的点
        }
    }
    if(low[u] == dfn[u]) {
        int now;
        do {
            now = stk.top();
            stk.pop();
            vis[now] = 0;
            tar[tag].push_back(now);
            scc[now] = tag;
        } while(now != u);
        tag ++;
    }
}
void all_tarjan() {
    for(int i = 0; i < n; i ++) {
        if(!dfn[i]) {
            tarjan(i, i);
        }
    }
}
// 缩点
void regra() {
    for(int i = 0; i < n; i ++) {
        int u = i;
        for(auto [v, yes] : e[i]) {
            int x = scc[u], y = scc[v];
            if(x != y) {
                che[x].push_back(y);
                deg[y] ++;
            }
        }
    }
}
```

## 2-SAT

判断是否存在满足布尔方程 $(a\vee b)\wedge (c\vee d)...$ 的一组可行解。

通过将上述布尔方程进行转化（蕴含），$a\vee b=\neg a \rightarrow b \wedge \neg b \rightarrow a$ ，继而将其转化为一个图上问题，通过判断 $a$ 和 $\neg a$ 是否在同一个强连通分量判断。特殊的 $a = \neg a \rightarrow a$，这在构造可行解是必须的。

2-SAT 的构造是对于每个变量取拓扑序大的那个（用 tarjan 处理后的拓扑序为倒序）。

## 割点

割点：删去这个点后会导致整张图的联通分量增大。

```cpp
const int MAXN = 2e5 + 10;
vector<int> e[MAXN];
int n, m, tim;
// low表示该点能到达的非父祖宗的最小时间戳
int low[MAXN], dfn[MAXN];
vector<int> res;
void tarjan(int u, int fa) {
    dfn[u] = low[u] = ++ tim;
    int c = 0;                                  // 孩子个数
    for(auto v : e[u]) {
        if(!dfn[v]) {                           // 是父子边
            tarjan(v, u);
            low[u] = min(low[u], low[v]);       // 更新low
            if(low[v] >= dfn[u] && u != fa) {   // 发现必须通过父亲节点到达祖宗节点
                res.push_back(u);
            }
            c ++;
        }
        low[u] = min(low[u], dfn[v]);
    }
    // u为根节点且有大于1个之间孩子，则根节点为割点
    if(c > 1 && u == fa) {
        res.push_back(u);
    }
}
void tarjan_all() {
    for(int i = 0; i < n; i ++) {
        if(!dfn[i]) {
            tarjan(i, i);
        }
    }
}
void solve() {
    tarjan_all();
    // 可能会重复计数割点
    sort(res.begin(), res.end());
    res.resize(unique(res.begin(), res.end()) - res.begin());
}
```

## 双连通分量

在一个无向连通图中，对于两个点 $u, v$ 如果删除任意一条边都不能使其不连通，则称 $u, v$ 边双连通。

> 在以 $u$ 为源点， $v$ 为汇点的网络流模型中，其具象化的表现为 $u \rightarrow v$ 的流量至少为 $2$。

在一个无向连通图中，对于两个点 $u, v$ 如果删除任意一个点都不能使其不连通，则称 $u, v$ 点双连通。

> 在以 $u$ 为源点， $v$ 为汇点的网络流模型中，通过对（非源、汇点）拆点的操作——每个点拆成中间连一条容量为 $1$ 的边，其具象化的表现为 $u \rightarrow v$ 的流量至少为 $2$。

- 点双连通图
    图上任意两个点 $u, v$ 都是点双连通的。一个近乎等价的定义——一张连通图上不存在割点（仅在两个点一条边的情况下实效）。

## 圆方树

将一张图分成 $k$ 个极大点双连通分量，每一个点双建一个方点，这个方点和该点双内的所有圆点连一条边（原图上的点成为圆点，每个点双创建的新的点称为方点）。

在圆方树中与多个方点所相连的圆点是原图上的割点。

下面是一张无向图转化为圆方树的形态。

![1](C:\Users\ryan\Desktop\blog\source\images\圆方树\image1.png)

```cpp
int n, m, k, cnt;
vector<int> gra[MAXN], tre[MAXN << 1];
int dfn[MAXN], low[MAXN], tim;
stack<int> stk;
void init() {
    for(int i = 0; i < n * 2; i ++) {
        tre[i].clear();
    }
    for(int i = 0; i < n; i ++) {
        dfn[i] = low[i] = 0;
    }
    tim = 0, cnt = n;
    while (!stk.empty()) {
        stk.pop();
    }
}
void Tarjan(int u) {
    dfn[u] = low[u] = ++ tim;
    stk.push(u);
    for(int v : gra[u]) {
        if(!dfn[v]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
            if(low[v] == dfn[u]) {
                for(int x = 0; x != v; stk.pop()) {
                    x = stk.top();
                    tre[cnt].push_back(x);
                    tre[x].push_back(cnt);
                }
                tre[u].push_back(cnt);
                tre[cnt].push_back(u);
                cnt ++;
            }
        } else {
            low[u] = min(low[u], dfn[v]);
        }
    }
    return res;
}
```

## 基环树找环

```cpp
int n, m;
vector<int> G[MAXN];
namespace Circle {
    vector<int> circle; // 环上的点
    int tag[MAXN]; // 标记: -1未访问; 1访问过; 2在环上
    void init() {
        for(int i = 0; i < n; i ++) {
            tag[i] = -1;
        }
    }
    int dfs(int u, int f) {
        if(tag[u] != -1) {
            return u;
        }
        tag[u] = 1;
        for(auto v : G[u]) if(v != f) {
            int t = dfs(v, u);
            if(t > -1) {
                circle.push_back(u);
                tag[u] = 2;
                return t == u ? -1 : t;
            }
        }
        return -1;
    }
}
```

## 匈牙利算法

用于解决二分图匹配和二分图的最小点覆盖

```cpp
int n, m;            // M, N分别表示左、右侧集合的元素数量
vector<int> G[MAXN];
int p[MAXN];         // 记录当前右侧元素所对应的左侧元素
bool vis[MAXN];      // 记录右侧元素是否已被访问过
bool match(int i) {
    bool ok = 0;
    for(int v : G[i]) if(!vis[v]) {
        vis[v] = 1;
        if(!ok && (p[v] == 0 || match(p[v]))) {
            p[v] = i;
            ok = 1;
        }
        // vis[v] = 0; 可能会用到的优化
    }
    return ok;
}
int Hungarian() {
    int cnt = 0;
    for(int i = 1; i <= n; ++i) {
        memset(vis, 0, sizeof vis);
        if(match(i)) {
            cnt ++;
        }
    }
    return cnt;
}
```

## 最大流 Dinic

```cpp
namespace Dinic {
    using ll = long long;
    const int MAX_V = 500;
    const ll INF = 1e12;
    struct Edge {
        int from, to;
        ll  cup, flow;
        Edge(int u, int v, ll c, ll f) : from(u), to(v), cup(c), flow(f) {}
    };
    struct Graph {
        int s, t, n, m;
        vector<Edge> es;
        vector<int> G[MAX_V];
        int level[MAX_V], iter[MAX_V];
        bool vis[MAX_V];
        Graph(int s, int t, int n = MAX_V) : n(n), s(s), t(t) {
            es.clear();
            for(int i = 0; i < n; i ++) {
                G[i].clear();
            }
        };
        void addEdge(int u, int v, ll c) {
            es.push_back({u, v, c, 0}), es.push_back({v, u, 0, 0});
            m = es.size();
            G[u].push_back(m - 2), G[v].push_back(m - 1);
        }
        ll dfs(int v, ll f) {
            if(v == t || f == 0) return f;
            ll flow = 0, d;
            for(int &i = iter[v]; i < G[v].size(); i ++) {
                auto &e = es[G[v][i]], &reve = es[G[v][i] ^ 1];
                if(level[v] + 1 == level[e.to] && (d = dfs(e.to, min(f, e.cup - e.flow))) > 0) {
                    e.flow += d, reve.flow -= d;
                    flow += d;
                    f -= d;
                    if(! f) break;
                }
            }
            return flow;
        }
        bool bfs() {
            memset(vis, false, sizeof vis);
            queue<int> q;
            q.push(s);
            level[s] = 0;
            vis[s] = true;
            while(q.size()) {
                int v = q.front();
                q.pop();
                for(int i = 0; i < G[v].size(); i ++) {
                    auto &e = es[G[v][i]], &reve = es[G[v][i] ^ 1];
                    if(!vis[e.to] && e.cup > e.flow) {
                        vis[e.to] = true;
                        level[e.to] = level[v] + 1;
                        q.push(e.to);
                    }
                }
            }
            return vis[t];
        }
        ll maxflow() {
            ll flow = 0;
            while(bfs()) {
                memset(iter, 0, sizeof iter);
                flow += dfs(s, INF);
            }
            return flow;
        }
    };
};
using namespace Dinic;
```

## 费用流 Primal Dual

```cpp
namespace Primal_Dual {
    using ll = long long;
    const int MAX_V = 5e3 + 10;
    const ll INF = 1e12;
    struct Edge {
        int from, to;
        ll cup, flow, cost;
        Edge(int u, int v, ll c, ll f, ll w) : from(u), to(v), cup(c), flow(f), cost(w) {}
    };
    struct Graph {
        int n, m, s, t;
        vector<Edge> es;
        vector<int> G[MAX_V];
        ll dis[MAX_V], h[MAX_V];
        int prevv[MAX_V], preve[MAX_V];
        bool vis[MAX_V];
        
        Graph(int s, int t, int n = MAX_V) : s(s), t(t), n(n) {
            es.clear();
            for(int i = 0; i < n; i ++) {
                G[i].clear();
            }
        }
        void add_Edge(int u, int v, ll cup, ll cost) {
            es.push_back({u, v, cup, 0, cost}), es.push_back({v, u, 0, 0, -cost});
            m = es.size();
            G[u].push_back(m - 2), G[v].push_back({m - 1});
        }
        void spfa() {
            queue<int> q;
            memset(h, 0x3f, sizeof h);
            h[s] = 0, vis[s] = true;
            q.push(s);
            while(q.size()) {
                int u = q.front();
                q.pop();
                vis[u] = false;
                for(int i : G[u]) {
                    const Edge& e = es[i];
                    if(e.cup > e.flow && h[e.to] > h[e.from] + e.cost) {
                        h[e.to] = h[e.from] + e.cost;
                        if(!vis[e.to]) {
                            q.push(e.to);
                            vis[e.to] = true;
                        }
                    }
                }
            }
        }
        struct mypair {
            ll dis; 
            int id;
            bool operator< (const mypair& a) const {
                return dis > a.dis;
            }
        };
        bool Dij() {
            for(int i = 0; i < n; i ++) {
                dis[i] = INF;
            }
            memset(vis, 0, sizeof vis);
            priority_queue<mypair> q;
            dis[s] = 0;
            q.push({dis[s], s});
            while(q.size()) {
                int u = q.top().id;
                q.pop();
                if(vis[u]) continue;
                vis[u] = true;
                for(int i : G[u]) {
                    const Edge& e = es[i];
                    ll nc = e.cost + h[e.from] - h[e.to];
                    if(e.cup > e.flow && dis[e.to] > dis[e.from] + nc) {
                        dis[e.to] = dis[e.from] + nc;
                        prevv[e.to] = e.from;
                        preve[e.to] = i;
                        q.push({dis[e.to], e.to});
                    }
                }
            }
            return dis[t] != INF;
        }
        auto maxf_minc() {
            spfa();
            ll maxf = 0;
            ll minc = 0;
            while(Dij()) {
                ll f = INF;
                for(int i = 0; i < n; i ++) if(dis[i] != INF) {
                    h[i] += dis[i];
                }
                for(int x = t; x != s; x = prevv[x]) {
                    f = min(f, es[preve[x]].cup - es[preve[x]].flow);
                }
                for(int x = t; x != s; x = prevv[x]) {
                    es[preve[x]].flow += f;
                    es[preve[x] ^ 1].flow -= f;
                }
                maxf += f;
                minc += f * h[t];
            }
            return tuple<ll, ll>(maxf, minc);
        }
    };
};
using namespace Primal_Dual;
void solve() {
    int n, m, s, t;
    cin >> n >> m >> s >> t;
    Graph gra(s, t);
    for(int i = 0; i < m; i ++) {
        int u, v, cup, cost;
        cin >> u >> v >> cup >> cost;
        gra.add_Edge(u, v, cup, cost);
    }
    auto [maxf, minc] = gra.maxflow();
    cout << maxf << " " << minc << '\n';
}
```

## 网络流的概念及其技巧

网络：
- 带权有向图，含有源点 $s$ 和汇点 $t$。

流（flow）：
- 容量限制：$f(u, v) \leq c(u, v)$
- 反对称性：$f(u, v) = f(v,u)$
- 流量守恒：$\forall x \in V - \{s, t\}, \sum_{u, x} f(u, x) = \sum_{v, x} f(x, v)$，即对于任意一点，流入等于流出。

剩余容量：
- $c_f(u, v) = c(u, v) - f(u, v)$

残量网络：
- 有剩余容量构成的网络，包括两部分内容：1. 原图边、2. 原图的反向边。
- 残留网络记作 $G_f$。

增广路：
- 残留网络上一条从 $s$ 到 $t$ 的路径。

退流：
- 增量一条边的流量的同时要减少等量的反向边的流量。

最小割：
- 如果在残量网络上找不到一条增广路，则说明已经求出了最大流/最小割，此时原图被分为$S-T$两个点集合，称为最小割，其中最小割的容量（$S$连向$T$的有向边权和）等于最大流；$S$连向$T$的边集成为最小割边集。

可行边：
- $\exists$ 一个最小割边集 $E_s$, $e \subseteq E_s$。简单来说就是一条可行边属于所有最小割边集的并集。
- 性质：
    1. 在某个最小割上满流，这是必要条件。
    2. 对于$e(u, v)$，残量网络上不存在另一条从$u$到$v$的路径（简言之就是重边）。
    体现在图上就是$u$和$v$不在同一个$scc$中，因为反向边的存在，不满流的边相当于无向边，满流的边相当于没有边。

必须边：
- $\forall$ 最小割边集 $E_s$, $e \subseteq E_s$。简单来说就是一条可行边属于所有最小割边集的交集。
- 性质：
    1. 必须边 $\subseteq$ 可行边
    2. 在满足可行边的基础上，源点 $s$ 和 $u$ 属于同一个 $scc$，汇点 $t$ 和 $v$ 属于同一个 $scc$，直观上看就是从源点 $bfs$ 找到的割边等于从汇点 $bfs$ 找到的割边。

图的几个概念：
- 匹配：选出某些边,使得每两个边没有公共端点。
- 顶点覆集：选出某些点,每条边都至少有一个端点被选择。
- 独立集：选出某些点,使得每两个点没有连边。
- 边覆集：在`DAG`上用(边)不相交的简单路径覆盖所有的节点。

网络流题讲究对着限制找 flow，对着代价找 cost。

# 数学

## 数论定理

- 裴蜀定理

$ax + by = c有整数解 \iff gcd(a,b)|c$

- 费马小定理

若$p$为质数，$gcd(a, p) = 1$，则有$a^{p-1} \equiv 1 (mod\ p)$

- 欧拉函数

$φ(x) = \sum_{i = 1}^{x} [i \nmid x]$

```cpp
int phi(int n) {
    int res = n;
    for(int i = 2; i * i < n; i ++) {
        if(n % i == 0) {
            res = res / i * (i - 1);
            while(n % i == 0) n /= i;
        }
    }
    if(n > 1) {
        res = res / n * (n - 1);
    }
    return res;
}
```

- 欧拉定理
  

若 $gcd(a, m) = 1$， 则$a^{φ(m)} \equiv 1 (mod \ m)$

- 扩展欧拉定理

$$
\\a^b\equiv
\left\{
\begin{matrix}
a^{b\ mod\ φ(m)},\qquad\qquad\qquad\qquad gcd(a,m) = 1\\
a^b,\qquad\qquad\qquad \ \ \ gcd(a,m) \neq 1, b < φ(m)\\
a^{(b\ mod\ φ(m)) + φ(m)},gcd(a,m) \neq 1, b >= φ(m)\\
\end{matrix}
\right.
\qquad mod \ m\\
$$

## 筛

- 质数筛

```cpp
const int MAXN =3000010; 
vector<int> prime;
vector<bool> is_prime(MAXN, 1);
void Ola(int N) {
    is_prime[0] = is_prime[1] = 0;
    for(int i = 2; i <= N; i ++) {
        if(is_prime[i]) {
            prime.push_back(i);
        }
        for(int j = 0; i * prime[j] <= N && j < prime.size(); j ++) {
            is_prime[prime[j] * i] = 0;
            if(! (i % prime[j])) {
                break; 
            }
        }
    }
}
```

- 欧拉函数筛

```cpp
const int MAXN =3000010; 
vector<int> phi(MAXN);
vector<int> prime;
vector<bool> is_prime(MAXN, 1);
void solve() {
    is_prime[0] = is_prime[1] = 0;
    phi[1] = 1; 
    for(int i = 2; i <= MAXN; i ++) {
        if(is_prime[i]) {
            prime.push_back(i);
            phi[i] = i - 1;
        }
        for(int j = 0; i * prime[j] <= MAXN && j < prime.size(); j ++) {
            is_prime[prime[j] * i] = 0;
            if(i % prime[j]) {
                phi[prime[j] * i] = phi[prime[j]] * phi[i];
            } else {
                phi[prime[j] * i] = prime[j] * phi[i];
                break;
            }
        }
    }
}
```

## exgcd 及其应用

```cpp
int exgcd(int a, int b, int &x, int &y) {
    int d = a;
    if(b) {
        d = exgcd(b, a % b, y, x);
        y -= (a / b) * x;
    } else {
        x = 1, y = 0;
    }
    return d;
}
```

- 扩欧求乘法逆元
```cpp
int inv(int a, int m) {
    int x, k;
    exgcd(a, m, x, k);
    return (x + m) % m;
}
```

## 矩阵快速幂

- 用于递推式，如斐波那契数列。
```cpp
typedef vector<vector<int>> mat;
mat mul(mat &A, mat &B) {
    int n = A.size(), t = A[0].size(), m = B[0].size();
    mat C(A.size(), vector<int> (B[0].size()));
    for(int i = 0; i < n; i ++) {
        for(int j = 0; j < m; j ++) {
            for(int k = 0; k < t; k ++) {
                C[i][j] = (1ll * C[i][j] + 1ll * A[i][k] * B[k][j]) % mod;
            }
        }
    }
    return C;
}
mat qpow(mat &A, ll k) {
    int n = A.size();
    mat res(n, vector<int> (n));
    for(int i = 0; i < n; i ++) {
        res[i][i] = 1;
    }
    while(k) {
        if(k & 1) {
            res = mul(res, A);
        }
        A = mul(A, A);
        k >>= 1;
    }
    return res;
}
```

## 线性基

线性基通常指一组多维向量的极大线性无关组，通常可以用高斯消元法求出。

但是在算法竞赛中，有一种特殊的处理方式针对一组数的异或运算。在 $mod\ 2$ 域内，任意一个维度仅有零向量与单位向量，而异或正是一种非常便利的在 $mod 2$ 域内的”高斯消元“。

```cpp
struct LBase {
    int dims = 0;
    vector<ll> d;
    LBase(int n = 62) : dims(n) {
        d.resize(n);
    }
    bool insert(ll x) {
        for (int i = dims - 1; i >= 0; i --)
            if (x & ((ll)1 << i)) {
                if(d[i]) {
                    x ^= d[i];
                } else {
                    d[i] = x;
                    break;
                }
            }
        return x > 0;
    }
    ll get_max() {
        ll x = 0;
        for (int i = dims - 1; i >= 0; i --) if(d[i]) {
            x = max(x, x ^ d[i]);
        }
        return x;
    }
    bool check_ex(ll x) {
        for(int i = dims - 1; i >= 0; i --) {
            if(x & (1 << i)) {
                if(!d[i])  {
                    return false;
                }
                x ^= d[i];
            }
        }
        return true;
    }
    void merge(const LBase &a) {
        for (int i = a.dims - 1; i >= 0; i --) if(a.d[i]) {
            insert(a.d[i]);
        }
    }
    int get_ranks() {
        int ranks = 0;
        for(int i = 0; i < dims; i ++) {
            ranks += (d[i] > 0);
        }
        return ranks;
    }
};
```

## 组合数

```cpp
const int MAXN = 1e6 + 10, mod = 1e9 + 7;
ll fact[MAXN], inv[MAXN];
ll qpow(ll x, ll y) {
    ll res = 1;
    while(y) {
        if(y & 1) (res *= x) %= mod;
        (x *= x) %= mod;
        y >>= 1;
    }
    return res;
}
void init() {
    inv[0] = fact[0] = 1;
    for(int i = 1; i < MAXN; i ++)  {
        fact[i] = fact[i - 1] * i % mod;
    }
    inv[MAXN - 1] = qpow(fact[MAXN - 1], mod - 2);
    for(int i = MAXN - 2; i >= 1; i --) {
        inv[i] = inv[i + 1] * (i + 1) % mod;
    }
}
ll cal(ll n, ll m) {
    return (fact[n] * inv[m] % mod)* inv[n - m] % mod;
}
```


**Lucas卢卡斯定理**

- 给出递推式, 对于质数$p$, 有

$$
\binom{n}{m}\bmod p = \binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p
$$

因此当组合数过大的时候可以利用卢卡斯定理递归求解,时间复杂度为$O(f(p) + g(n)log\ n)$

```cpp
ll fact[mod], inv[mod];
ll qpow(ll x, ll y) {
    ll res = 1;
    while(y) {
        if(y & 1) {
            (res *= x) %= mod;
        }
        (x *= x) %= mod;
        y >>= 1;
    }
    return res;
}
void init() {
    fact[0] = inv[0] = 1;
    for(int i = 1; i < MAXN; i ++) {
        fact[i] = fact[i - 1] * i % mod;
    }
    inv[MAXN - 1] = qpow(fact[MAXN - 1], mod - 2); 
    for(int i = mod - 2; i > 0; i --) {
        inv[i] = inv[i + 1] * (i + 1) % mod;
    }
}
ll C(ll n, ll m) {
    if(m > n) return 0;
    return fact[n] * inv[m] * inv[n - m] % mod;
}
ll lucas(ll n, ll m) {
    if(m == 0) return 1;
    return C(n % mod, m % mod) * lucas(n / mod, m / mod);
}
```

## 博弈论

**公平组合游戏 （Impartial Combinatorial Games，ICG）**

1. 两名玩家轮流对当前游戏状态在一个有限集合中进行一次操作。
2. 一个局面的合法操作，只取决于游戏本身固然存在，而与玩家的次序或其他因素无关。
3. 对于无法进行任何操作的玩家，即操作集合为空，则另一方获胜。

**Nim游戏**

> $n$ 堆物品，每堆有 $a_i$ 个，两个玩家轮流取走任意一堆的任意个物品，但不能不取，不能操作的玩家为负。

Nim 游戏的结论是所有的 $\bigoplus _{i = 1} ^ {n} a_i = 0$ 为先手必败。

**SG函数**

将游戏状态和所有的合法操作抽象为有向无环图（DAG）。

定义没有后继的状态为必败状态。

一个必胜状态的后继中存在一个必败状态。

一个必败状态的后继中不存在一个必败状态。

> 这里给出一个不是非常严格的理解，上面所有的必胜状态和必败状态都是对于当前所需进行操作的玩家来说的，没有后继的状态为必败状态是游戏结束的前提，对于一个必胜状态，该玩家一定可以通过一种操作到达一种必败状态使自己胜利；对于一个必败状态，如果存在一个必败状态的后继，那么当前操作的玩家就可以通过一种操作到达一个必败状态使自己胜利，这与当前是必败状态所矛盾，因此一个必败状态的后继一定不存在一个必败状态。

给所有的状态设置一个 $SG$ 值，对于 $SG$ 函数有如下定义：

$$
SG(x) = MEX\lbrace SG(y_1), SG(y_2), SG(y_3), ..., SG(y_n)\rbrace, \forall i, x \rightarrow y_i
$$

如果只进行一次博弈的话，求 SG 函数没有任何优势，但是对于一个博弈包含多个子博弈有如下定理：

$$
SG(x_1 + x_2 + ... + x_n) = SG(x_1) \bigoplus SG(x_2) \bigoplus ... \bigoplus SG(x_n)
$$

> 这里对该结论不进行详细证明，详见[OI-wiki](https://oi-wiki.org/math/game-theory/impartial-game/)

其中，将 $n$ 个子博弈的并行关系用 $+$ 运算连接，每个子博弈都能求出一个 SG 值。

例如在 Nim 游戏中将每堆物品看成一个子游戏，那么整个游戏的 SG 值为所有子游戏的 SG 值的异或和。

SG值为 $0$ 为先手必败。

**MEX**

```cpp
// v可以是vector、set等容器 
int mex(auto v) {
    unordered_set<int> S;
    for (auto e : v) {
        S.insert(e);
    }
    for (int i = 0;; ++i) {
        if (S.find(i) == S.end()) {
            return i;
        }
    }
}
```

## 中国剩余定理CRT

求解模数互质的线性同余方程组

流程:

1. 算出所有模数的乘积 $M$。
2. 对第$i$给方程求出$M_i=M / m_i$。
3. $x=\sum_{i = 1}^{n}a_i * M_i * m_i^{-1}$。

```cpp
void exgcd(ll a, ll b, ll &x, ll &k) {
    if(b) {
        exgcd(b, a % b, k, x);
        k -= (a / b) * x;
    } else {
        x = 1, k = 0;
    }
}
ll inv(ll a, ll b) {
    ll x, k;
    exgcd(a, b, x, k);
    return (x + b) % b;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    vector<int> a(n), b(n); // a为模数, b为余数
    ll M = 1;
    for(int i = 0; i < n; i ++) {
        cin >> a[i] >> b[i];
        M *= a[i];
    }
    ll x = 0;
    for(int i = 0; i < n; i ++) {
        ll m = M / a[i];
        (x += (b[i] * m % M) * inv(m, a[i]) % M) %= M;
    }
    cout << x << '\n';
}
```

## FFT

```cpp
const double pi = acos(-1);
const int MAXN = 5e6 + 10;
int R[MAXN];
void fft(vector<complex<double>> &A,int type){
    int n = A.size();
    for(int i = 0; i < n; i ++) {
        if(i < R[i]) swap(A[i], A[R[i]]);
    }
    for(int mid = 1; mid < n; mid <<= 1) {
        complex<double> wn(cos(pi / mid), type * sin(pi / mid));
        for(int len = mid << 1, pos = 0; pos < n; pos += len){
            complex<double> w(1, 0);
            for(int k = 0; k < mid; k ++, w = w * wn) {
                complex<double> x = A[pos + k];
                complex<double> y = w * A[pos + mid + k];
                A[pos + k] = x + y;
                A[pos + mid + k] = x - y;
            }
        }
    }
}
void solve(){
    int n1, n2, n = 1, pr = 0;
    cin >> n1 >> n2;
    while(n <= n1 + n2) {
        n <<= 1, pr ++;
    }
    for(int i = 0; i < n; i ++) {
        R[i] = (R[i / 2] >> 1) | ((i & 1) << (pr - 1));
    }
    vector<complex<double>> a(n), b(n);
    for(int i = 0; i <= n1; i ++) {
        cin >> a[i];
    }
    for(int i = 0; i <= n2; i ++) {
        cin >> b[i];
    }
    fft(a, 1);
    fft(b, 1);
    for(int i = 0; i < n; i ++) {
        a[i] *= b[i];
    }
    fft(a, -1);
    for(int i = 0; i <= n1 + n2; i ++) {
        cout << (int)(a[i].real() / n + 0.5) << ' ';
    }
}
```

## 整数分块

计算形如$\sum_{i=1}^{n}f(i)g(\lfloor\frac{n}{i}\rfloor)$可以在$O(\sqrt{n})$的时间内求出。

```cpp
int n;
cin >> n;
vector<int> f(n + 1), sum(n + 1);
for(int i = 1; i <= n; i ++) cin >> f[i];
for(int i = 1; i <= n; i ++) sum[i] = sum[i - 1] + f[i];
int l = 0, r = 1, res = 0;
while(l <= n) {
    r = n / (int)(n / l);
    res +=  (sum[r] - sum[l - 1]) * (int)(n / l);
    l = r + 1;
}
cout << res;
```

# 字符串

## KMP

```cpp
bool KMP(string s, string t) {
    int n = s.size(), m = t.size();
    vector<int> ne(m);
    for(int i = 1, k = 0; i < m; i ++) {
        while(k > 0 && t[i] != t[k]) {
            k = ne[k - 1];
        }
        if(t[i] == t[k]) {
            k ++;
        }
        ne[i] = k;
    }
    for(int i = 0, j = 0; i < n; i ++) {
        while(j > 0 && s[i] != t[j]) {
            j = ne[j - 1];
        }
        if(s[i] == t[j]) {
            j ++;
        }
        if(j == m) {
            return 1;
        }
    }
    return 0;
}
```

## Manacher

查找一个字符串中的最长回文子串(不是最长回文序列)的线性算法。

```cpp
int Manacher(string s) {
    string t;
    t += "$#";
    for(char c : s) {
        t += c;
        t += '#';
    }
    int len = t.size();
    vector<int> p(len);
    int res = 0;
    for(int i = 1, r = 0, m = 0; i < len; i ++) {
        if(i <= r) p[i] = min(p[m * 2 - i], r - i + 1);
        while(t[i - p[i]] == t[i + p[i]]) p[i] ++;
        if(p[i] + i > r) r = p[i] + i - 1, m = i;
        if(p[i] > res) res = p[i];
    }
    return res - 1;
}
```

# 计算几何

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Geometry_2D {
    struct Point;
    struct Line;
    struct Seg;
    struct Polygon;
    struct Circle;
    enum Position { CCW = 1, CW = -1, BACK = 2, FORNT = -2, ON = 0 };
    enum Contain { in = 2, on = 1, out = 0 };
    using Real = double; // can change it if need Integer
    const Real eps = 1e-8;
    const Real INF = 1e18;
    const Real PI = acos(static_cast<Real>(-1));
    inline int sgn(const Real& r) {
        return r < -eps ? -1 : r > eps ? 1 : 0;
    }
    inline int cmp(const Real &a, const Real &b) {
        return abs(a - b) <= eps ? 0 : a > b ? 1 : -1;
    }
    inline bool eq(const Real &a, const Real &b) {
        return cmp(a, b) == 0;
    }
    // 声明
    Real dis(const Point& a, const Point& b);
    Real dis(const Line& l, const Point& p);
    Real dis(const Line& l, const Line& m);
    Real dis(const Line& l, const Seg& s);
    Real dis(const Seg& s, const Point& p);
    Real dis(const Seg& s, const Seg& t);
    bool intersect(const Line& l, const Point& p);
    bool intersect(const Line& l, const Line& m);
    bool intersect(const Line& l, const Seg& s);
    bool intersect(const Seg& s, const Point& p);
    bool intersect(const Seg& s, const Seg& t);
    bool intersect(const Circle& O, const Line& l);
    int intersect(const Circle& O, const Seg& s);
}
// point/vector, line, segment, circle
namespace Geometry_2D {
    // Point or Vector
    struct Point {
        Real x, y;
        Point() {}
        Point(Real a, Real b) : x(a), y(b) {}
        friend ostream& operator<<(ostream& os, const Point& v) {
			return os << v.x << " " << v.y;
		}
		friend istream& operator>>(istream& is, Point& v) {
			return is >> v.x >> v.y;
		}
        Point& operator+=(const Point& p) {
            x += p.x, y += p.y;
            return *this;
        }
        Point& operator-=(const Point& p) {
            x -= p.x, y -= p.y;
            return *this;
        }
        Point& operator*=(const Real& k) {
            x *= k, y *= k;
            return *this;
        }
        Point& operator/=(const Real& k) {
            x /= k, y /= k;
            return *this;
        }
        Point operator-() {
            return Point(-x, -y);
        }
        Point operator+(const Point& p) const {
            return Point(*this) += p;
        }
        Point operator-(const Point& p) const {
            return Point(*this) -= p;
        }
        Point operator*(const Real& k) const {
            return Point(*this) *= k;
        }
        Point operator/(const Real& k) const {
            return Point(*this) /= k;
        }
        bool operator==(const Point& p) {
            return eq(x, p.x) && eq(y, p.y);
        }
        bool operator!=(const Point& p) {
            return !(*this == p);
        }
        bool operator<(const Point& p) const { 
            return cmp(x, p.x) < 0 || (eq(x, p.x) && cmp(y, p.y) < 0);
        }
        bool operator>(const Point& p) const {
            return cmp(x, p.x) > 0 || (eq(x, p.x) && cmp(y, p.y) > 0);
        }
        // 叉积
        friend Real crs(const Point &a, const Point &b) {
            return a.x * b.y - b.x * a.y;
        }
        // 点积
        friend Real dot(const Point &a, const Point &b) {
            return a.x * b.x + a.y * b.y;
        }
        Real norm() const {
            return x * x + y * y;
        }
        // 模长
        Real abs() const {
            return std::hypot(x, y);
        }
        // 极角
        Real arg() const {
            return std::atan2(y, x);
        }
        // 旋转 270
        Point normal() const {
            return Point(-y, x);
        }
        Point unit() const {
            return *this / abs();
        }
        // 旋转
        Point rotate(Real theta) const {
            return Point(x * std::cos(theta) - y * std::sin(theta),
                         x * std::sin(theta) + y * std::cos(theta));
        }
    };
    typedef Point Vec;
    using Points = vector<Point>;
    // 直线
    struct Line {
        Point a, b;
        Line() {}
        Line(const Point &a, const Point &b) : a(a), b(b) {}
        Line(const Real& A, const Real& B, const Real& C) {  // Ax + By = c
            if (eq(A, 0)) {
                assert(!eq(B, 0));
                a = Point(0, C / B), b = Point(1, C / B);
            } else if (eq(B, 0)) {
                a = Point(C / A, 0), b = Point(C / A, 1);
            } else {
                a = Point(0, C / B), b = Point(C / A, 0);
            }
        }
        friend ostream& operator<<(ostream& os, const Line& l) {
			return os << l.a << " " << l.b << '\n';
		}
		friend istream& operator>>(istream& is, Line& l) {
			return is >> l.a >> l.b;
		}
        Point diff() const {
            return b - a;
        }
    };
    using Lines = vector<Line>;
    // 线段
    struct Seg : Line {
        Seg() {}
        Seg(Point a, Point b) : Line(a, b) {}
        Real len() const { return diff().abs(); }
    };
    // 圆
    struct Circle {
        Point c;
        Real r;
        Circle() {}
        Circle(const Point& c, const Real& r) : c(c), r(r) {}
        friend ostream& operator<<(ostream& os, const Circle& c) {
			return os << c.c << " " << c.r << '\n';
		}
		friend istream& operator>>(istream& is, Circle& c) {
			return is >> c.c >> c.r;
		}
    };
}
// basal function
namespace Geometry_2D {
    Point polar(const Real& r, const Real& theta) {
        return Point(cos(theta), sin(theta)) * r;
    }
    // 点在直线上的投影 Project
    Point proj(const Point& p, const Line& l) {
        Point v = l.diff().unit();
        return l.a + v * dot(v, p - l.a);
    }
    // 点关于直线的对称 Reflect
    Point refl(const Point& p, const Line& l) {
        Point h = proj(p, l);
        return h + (h - p);
    }
    // 中垂线
    Line midline(const Point& p, const Point& q) {
        Point c = (p + q) * 0.5;
        Point v = (q - p).normal();
        return Line(c - v, c + v);
    }
    // 两直线平行
    bool LPL(const Line& a, const Line& b) {
        return eq(crs(a.diff(), b.diff()), 0);
    }
    // 两直线垂直
    bool LOL(const Line& a, const Line& b) {
        return eq(dot(a.diff(), b.diff()), 0);
    }
    // c 和 ab 的位置关系 (CCW : 1, CW : -1, BACK : 2, FRONT : -2, ON : 0)
    int ccw(const Point& a, Point b, Point c) {
        b -= a, c -= a;
        if(sgn(crs(b, c)) == +1) return CCW;
        if(sgn(crs(b, c)) == -1) return CW;
        if(sgn(dot(b, c)) == -1) return BACK;
        if(cmp(b.norm(), c.norm()) == -1) return FORNT;
        return ON;
    }
    int ccw(const Point& a,const Point& b) {
        return ccw(Point(0, 0), a, b);
    }
    // 距离
    Real dis(const Point& a, const Point& b) {
        return (a - b).abs();
    }
    Real dis(const Line& l, const Point& p) {
        return dis(p, proj(p, l));
    }
    Real dis(const Point &p, const Line& l) {
        return dis(l, p);
    }
    Real dis(const Line& l, const Line& m) {
        return intersect(l, m) ? 0 : dis(l, m.a);
    }
    Real dis(const Line& l, const Seg& s) {
        return intersect(l, s) ? 0 : std::min(dis(l, s.a), dis(l, s.b));
    }
    Real dis(const Seg& s, const Line& l) {
        return dis(l, s);
    }
    Real dis(const Seg& s, const Point& p) {
        Point h = proj(p, s);
        return intersect(s, h) ? dis(p, h) : std::min(dis(p, s.a), dis(p, s.b));
    }
    Real dis(const Point& p, const Seg& s) {
        return dis(p, s);
    }
    Real dis(const Seg& s, const Seg& t) {
        if (intersect(s, t)) return 0;
        return std::min({dis(s, t.a), dis(s, t.b), dis(t, s.a), dis(t, s.b)});
    }
    // 相交测试
    bool intersect(const Line& l, const Point& p) {
        return abs(ccw(l.a, l.b, p)) != 1;
    }
    bool intersect(const Line& l, const Line& m) {
        Real A = crs(l.diff(), m.diff()), B = crs(l.diff(), l.b - m.a);
        if (eq(A, 0) && eq(B, 0)) return true;      // check if equal
        return !LPL(l, m);
    }
    bool intersect(const Line& l, const Seg& s) {
        return sgn(crs(l.diff(), s.a - l.a)) * sgn(crs(l.diff(), s.b - l.a)) <= 0;
    }
    bool intersect(const Seg& s, const Point& p) {
        return ccw(s.a, s.b, p) == 0;
    }
    bool intersect(const Seg& s, const Seg& t) {
        return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;
    }
    bool intersect(const Circle& O, const Line& l) {
        return cmp(O.r, dis(l, O.c)) >= 0;
    }
    bool intersect(const Line& l, const Circle& O) {
        return intersect(O, l);
    }
    int intersect(const Circle& c, const Seg& s) {
        Point h = proj(c.c, s);
        if (cmp(dis(c.c, h), c.r) > 0) return 0;
        Real d1 = (c.c - s.a).abs(), d2 = (c.c - s.b).abs();
        if (cmp(c.r, d1) >= 0 && cmp(c.r, d2) >= 0) return 0;
        if (cmp(c.r, d1) * cmp(c.r, d2) < 0) return 1;
        if (sgn(dot(s.a - h, s.b - h)) < 0) return 2;
        return 0;
    }
    // 求两直线交点
    Point crosspoint(const Line& l, const Line& m) {
        assert(intersect(l, m));
        Real A = crs(l.diff(), m.diff()), B = crs(l.diff(), l.b - m.a);
        if (eq(A, 0) && eq(B, 0)) return m.a;
        return m.a + m.diff() * B / A;
    }
    // lowest then leftest
    Point LTL(const Points &ps) {
        Point res = ps[0];
        for(auto p : ps) {
            if((p.y < res.y) || (eq(p.y, res.y) && p.x < res.x)) {
                res = p;
            }
        }
        return res;
    }
    // 海伦公式
    Real Area(const Point& a, const Point& b, const Point& c) {
        return abs(crs(b - a, c - a)) / 2;
    }
    // 以点 O 为原点进行极角排序 (CCW)，欧式距离为次关键字
    void CCWwhitO(Point O, Points &ps) {
        auto upp = [O](Point a) {
            if(a.y > O.y || (eq(a.y, O.y) && a.x >= O.x)) return true;
            return false;
        };
        auto cmp = [O, upp](Point a, Point b) {
            if(upp(a) != upp(b)) return upp(a);
            else {
                int s = sgn(crs(a - O, b - O));
                if(s == 0) {
                    return (a-O).norm() < (b - O).norm();
                } else {
                    return s > 0;
                }
            }
        };
        sort(ps.begin(), ps.end(), cmp);
    }
    // colsest Point pair
    Real closest_pair(Points ps) {
        int n = ps.size();
        if (n == 1) return 0;
        sort(ps.begin(), ps.end());
        auto cmp_y = [&](const Point& p, const Point& q) { return p.y < q.y; };
        vector<Point> cand(n);
        auto dfs = [&](auto self, int l, int r) -> Real {
            if (r - l <= 1) return INF;
            int mid = (l + r) >> 1;
            auto x_mid = ps[mid].x;
            auto res = min(self(self, l, mid), self(self, mid, r));
            inplace_merge(ps.begin() + l, ps.begin() + mid, ps.begin() + r, cmp_y);
            for (int i = l, cur = 0; i < r; i++) {
                if (abs(ps[i].x - x_mid) >= res) continue;
                for (int j = cur - 1; j >= 0; j--) {
                    Point diff = {ps[i].x - cand[j].x, ps[i].y - cand[j].y};
                    if (diff.y >= res) break;
                    res = min(res, diff.abs());
                }
                cand[cur++] = ps[i];
            }
            return res;
        };
        return dfs(dfs, 0, n);
    }
}
// polygon
namespace Geometry_2D {
    struct Polygon : Points {
        using Points::vector;
        Polygon() {}
        Polygon(int n) : Points(n) {}
        Real len () {
            Real res = 0;
            for(int i = 0; i < size(); i ++) {
                int j = (i + 1) % size();
                res += ((*this)[j] - (*this)[i]).abs();
            }
            return res;
        }
        Real Area() {
            Real res = 0;
            for(int i = 0; i < size(); i ++) {
                int j = (i + 1) % size();
                res += ((*this)[i].x + (*this)[j].x) * ((*this)[i].y - (*this)[j].y);
            }
            return abs(res) / 2;
        }
        bool is_convex(bool accept_on_segment = false) const {
            int n = size();
            for (int i = 0; i < n; i++) {
                if (accept_on_segment) {
                    if (ccw((*this)[i], (*this)[(i + 1) % n], (*this)[(i + 2) % n]) == CW) {
                        return false;
                    }
                } else {
                    if (ccw((*this)[i], (*this)[(i + 1) % n], (*this)[(i + 2) % n]) != CCW) {
                        return false;
                    }
                }
            }
            return true;
        }
    };
    // 判断点与多边形位置关系 ( 2 : in, 1 on : 0 out )
    int Iscontain(const Point &a, const Points &ps) {
        int cnt = 0;
        for(int i = 0; i < ps.size(); i ++) {
            int j = (i + 1) % ps.size();
            Point u = ps[i] - a, v = ps[j] - a;
            if(u.y > v.y) swap(u, v);
            if(u.y <= 0 && v.y > 0 && crs(u, v) < 0) cnt ++;
            if(crs(u, v) == 0 && dot(u, v) <= 0) return on;
        }
        return cnt % 2 ? in : out;
    }
}
// some function about convex polygon
namespace Geometry_2D {
    // 求凸包
    Polygon Convexhell(Points &ps) {
        sort(ps.begin(), ps.end(), [&] (Point a, Point b) {
            return a < b;
        });
        int n = ps.size(), k = 0;
        Polygon res(2 * n);
        for(int i = 0; i < n; res[k ++] = ps[i ++]) {
            while(k >= 2 && ccw(res[k - 2], res[k - 1], ps[i]) != CCW) {
                k --;
            }
        }
        for(int i = n - 2, t = k + 1; i >= 0; res[k ++] = ps[i --]) {
            while(k >= t && ccw(res[k - 2], res[k - 1], ps[i]) != CCW) {
                k --;
            }
        }
        res.resize(k - 1);
        return res;
    }
    // 求凸多边形直径
    Real Diameter(const Polygon& ps) {
        int n = ps.size();
        if(n < 3) {
            return (ps[1] - ps[0]).abs();
        }
        Real res = 0;
        for(int i = 0, j = 1, k = 2 % n; i < n; ++ i, (++ j) %= n) {
            while(crs(ps[j] - ps[i], ps[(k + 1) % n] - ps[k]) >= 0) {
                (++ k) %= n;
            }
            res = max(res, max((ps[i] - ps[k]).abs(), (ps[j]- ps[k]).abs()));
        }
        return res;
    }
    // 求凸多边形最小矩形覆盖 resp 返回矩形四角
    Real RectangleArea(const Polygon& ps, Points& resp) {
        int n = ps.size();
        Real res = 1e18;
        int pr = 1, pl = 1;
        for(int i = 0, j = 1, k = 2 % n; i < n; ++ i, (++ j) %= n) {
            while(crs(ps[j] - ps[i], ps[(k + 1) % n] - ps[k]) >= 0) {
                (++ k) %= n;
            }
            while(dot(ps[j] - ps[i], ps[pr] - ps[i])
                <= dot(ps[j] - ps[i], ps[(pr + 1) % n] - ps[i])
            ) {
                (++ pr) %= n;
            }
            if(!i) pl = pr;
            while(dot(ps[j] - ps[i], ps[pl] - ps[i])
                >= dot(ps[j] - ps[i], ps[(pl + 1) % n] - ps[i])
            ) {
                (++ pl) %= n;
            }
            auto S= (dot(ps[j] - ps[i], ps[pr] - ps[i]) - 
                    dot(ps[j] - ps[i], ps[pl] - ps[i])) /
                    (ps[i]- ps[j]).abs() *
                    dis(Line(ps[i], ps[j]), ps[k]);
            if(res > S) {
                res = S;
                auto l1 = Line(ps[i], ps[j]), l2 = Line(ps[k], ps[k] + l1.diff());
                resp[0] = proj(ps[pl], l1), resp[1] = proj(ps[pr], l1);
                resp[2] = proj(ps[pl], l2), resp[3] = proj(ps[pr], l2);
            }
        }
        return res;
    }
    // Convex cnt ( left than l )
    Points Convex_cut(const Points &ps, const Line &l) {
        Points res;
        int n = ps.size();
        for(int i = 0, j = 1; i < n; ++ i, (++ j) %= n) {
            Real crs1 = crs(l.diff(), ps[i] - l.a);
            Real crs2 = crs(l.diff(), ps[j] - l.a);
            if(crs1 > 0.) res.push_back(ps[i]);
            if(crs1 > 0. && crs2 <= 0.) res.push_back(crosspoint(Line (ps[i], ps[j]), l));
            else if(crs1 <= 0. && crs2 > 0.) res.push_back(crosspoint(Line (ps[i], ps[j]), l));
        }
        return res;
    }
}

// some function about Circle
namespace Geometry_2D {
    // 两个圆的公切线个数
    int count_tangent(const Circle& c1, const Circle& c2) {
        Real r1 = c1.r, r2 = c2.r;
        if (r1 < r2) return count_tangent(c2, c1);
        Real d = dis(c1.c, c2.c);
        if (cmp(d, r1 + r2) > 0) return 4;
        if (cmp(d, r1 + r2) == 0) return 3;
        if (cmp(d, r1 - r2) > 0) return 2;
        if (cmp(d, r1 - r2) == 0) return 1;
        return 0;
    }
    // 公切线
    Lines common_tangent(const Circle& c1, const Circle& c2) {
        if (c1.r < c2.r) return common_tangent(c2, c1);
        Lines res;
        Real g = dis(c1.c, c2.c);
        if (eq(g, 0)) return res;
        Point u = (c2.c - c1.c) / g, v = u.normal();
        for (int s : {-1, 1}) {
            Real h = (c1.r + c2.r * s) / g;
            if (eq(1 - h * h, 0))
                res.emplace_back(c1.c + u * c1.r, c1.c + (u + v) * c1.r);
            else if (cmp(1 - h * h, 0) > 0) {
                Point U = u * h, V = v * std::sqrt(1 - h * h);
                res.emplace_back(c1.c + (U + V) * c1.r, c2.c - (U + V) * c2.r * s);
                res.emplace_back(c1.c + (U - V) * c1.r, c2.c - (U - V) * c2.r * s);
            }
        }
        return res;
    }
    // 三角形外接圆
    Circle circumcircle(Point a, Point b, const Point& c) {
        Point O = crosspoint(midline(a, c), midline(b, c));
        return Circle(O, dis(O, c));
    }
    // 三角形内切圆
    Circle incircle(const Point& a, const Point& b, const Point& c) {
        Real A = (b - c).abs(), B = (c - a).abs(), C = (a - b).abs();
        Point O = (a * A + b * B + c * C) / (A + B + C);
        return Circle(O, dis(Seg(a, b), O));
    }
    Points crosspoint(const Circle& c, const Line& l) {
        Point h = proj(c.c, l);
        Real d = c.r * c.r - (c.c - h).norm();
        if (sgn(d) < 0) return {};
        if (sgn(d) == 0) return {h};
        Point v = l.diff().unit() * sqrt(d);
        return {h - v, h + v};
    }
    Points crosspoint(const Circle& c, const Seg& s) {
        int num = intersect(c, s);
        if (num == 0) return {};
        auto res = crosspoint(c, Line(s.a, s.b));
        if (num == 2) return res;
        if (sgn(dot(s.a - res[0], s.b - res[0])) > 0) swap(res[0], res[1]);
        return {res[0]};
    }
    // requirement : c != d ( 不重合 )
    Points crosspoint(const Circle& c1, const Circle& c2) {
        Real r1 = c1.r, r2 = c2.r;
        assert(!(eq(r1, r2) && sgn(dis(c1.c, c2.c) == 0)));
        if (r1 < r2) return crosspoint(c2, c1);
        Real d = dis(c1.c, c2.c);
        if (cmp(d, r1 + r2) > 0 || cmp(d, r1 - r2) < 0) return {};
        Real alpha = std::acos((r1 * r1 + d * d - r2 * r2) / (2 * r1 * d));
        Real theta = (c2.c - c1.c).arg();
        Point p = c1.c + polar(r1, theta + alpha);
        Point q = c1.c + polar(r1, theta - alpha);
        if (p == q) return {p};
        return {p, q};
    }
    // 切点
    Points tangent_to_circle(const Circle& c, const Point& p) {
        return crosspoint(c, Circle(p, sqrt((c.c - p).norm() - c.r * c.r)));
    }
    // 公共面积
    Real commonarea(Circle c1, Circle c2) {
        Real r1 = c1.r, r2 = c2.r;
        Real d = (c1.c - c2.c).abs();
        if (cmp(r1 + r2, d) <= 0) return 0;
        if (cmp(std::fabs(r1 - r2), d) >= 0) return PI * min(r1, r2) * min(r1, r2);
        Real res = 0;
        for (int _ = 0; _ < 2; _++) {
            r1 = c1.r, r2 = c2.r;
            Real cosine = (d * d + r1 * r1 - r2 * r2) / (2 * d * r1);
            Real theta = std::acos(cosine) * 2;
            res += (theta - std::sin(theta)) * r1 * r1 / 2;
            swap(c1, c2);
        }
        return res;
    }
    // 圆上两点 + 半径求圆心位置
    Points center_given_radius(const Point& a, const Point& b, const Real& r) {
        Point m = (b - a) * 0.5;
        Real d1 = m.abs();
        if (eq(d1, 0) || d1 > r) return {};
        Real d2 = sqrt(r * r - d1 * d1);
        Point n = m.normal() * d2 / d1;
        Point p = a + m - n, q = a + m + n;
        if (p == q) return {p};
        return {p, q};
    }
    int intersect(const Circle& c, const Polygon& ps) {
        Real d = 1e18;
        int n = ps.size();
        for(int i = 0; i < n; i ++) {
            d = min(d, dis(c.c, Seg(ps[i], ps[(i + 1) % n])));
        }
        int s = sgn(d - c.r);
        return s > 0 ? out : s < 0 ? in : on;
    }
}
```

## 闵可夫斯基和

定义: 对于欧式空间上的两个点集 $A, B$, 存在点集 $C$ 满足 $\{a + b \in C|a \in A,b\in B \}$ （$a, b$均为向量的形式）, 则称 $C$ 为$A, B$的闵可夫斯基和, 即

$$
    C = A + B
$$

差 (different):

$C = A - B = \{a - b | a \in A, b \in B\} = A + (-B)$

表示对$\forall a \in A, \forall b \in B, \exist c \in C (c = a - b)$

或者可以这样理解$\forall c \in C, \exists b \in B, \exist a \in A (a =  c + b)$

==warning==: 这里的加号和减号不是一对可以互逆的运算, $(A - B) + B \neq A$

- 例题 [战争](https://www.luogu.com.cn/problem/P4557)

题目大意: 有两个部落$A,B$, 两个部落分别有$n, m$个人, 如两个部落所围成的凸包没有重合的点, 则不会发生战争. 现在$B$部落的全部人打算向$(x, y)$向量迁移, 有$q$次询问, 问是否会发生战争.

思路是找到一个点集$C$, 满足$\forall c \in C, \exists b \in B 满足 c + b \in A$, 这和前面差的定义是相同的, 故此题转化为了求$C = A - B$, 然后每次询问二分判断点是否在$C$内.

参考代码 (包含了**闵可夫斯基和**以及**判断一个点是否在凸包内**):

```cpp
using Real = long long;
using Points = vector<Point>;
enum position { CCW = 1, CW = -1, ON = 0 };
int ccw(const Point& a, Point b, Point c) {
    b -= a, c -= a;
    if(crs(b, c) > 0) return CCW;
    if(crs(b, c) < 0) return CW;
    return ON;
}
int ccw(Point a, Point b) {
    return ccw(Point(0, 0), a, b);
}
Points Convexhell(Points& ps) {
    int n = ps.size(), k = 0;
    Points res(2 * n);
    sort(ps.begin(), ps.end());
    for(int i = 0; i < n; res[k ++] = ps[i ++]) {
        while(k >= 2 && ccw(res[k - 2], res[k - 1], ps[i]) != CCW) {
            k --;
        }
    }
    for(int i = n - 2, t = k + 1; i >= 0; res[k ++] = ps[i --]) {
        while(k >= t && ccw(res[k - 2], res[k - 1], ps[i]) != CCW) {
            k --;
        }
    }
    res.resize(k - 1);
    return res;
}
Points Minkowski(Points& A, Points& B) {
    int n = A.size(), m = B.size();
    Points res (n + m + 1);
    res[0] = A[0] + B[0];
    int k = 1, i = 0, j = 0;
    int cA = 0, cB = 0;
    while(cA < n && cB < m) {
        int nxi = (i + 1) % n, nxj = (j + 1) % m;
        Point x = A[nxi] - A[i];
        Point y = B[nxj] - B[j];
        if(ccw(x, y) == CCW) {
            res[k ++] = res[k - 1] + x;
            i = nxi, cA ++;
        } else if(ccw(x, y) == CW) {
            res[k ++] = res[k - 1] + y;
            j = nxj, cB ++;
        } else {
            res[k ++] = res[k - 1] + x + y;
            j = nxj, i = nxi;
            cA ++, cB ++;
        }
    }
    while(cA < n) {
        int nxi = (i + 1) % n;
        res[k ++] = res[k - 1] + A[nxi] - A[i];
        cA ++, i = nxi;
    }
    while(cB < m) {
        int nxj = (j + 1) % m;
        res[k ++] = res[k - 1] + B[nxj] - B[j];
        cB ++, j = nxj;
    }
    res.resize(k - 1);
    return res;
}
bool check_in(Point& p, Points& ps) {
    int n = ps.size();
    int O = 0, l = 1, r = n - 1;
    if(ccw(ps[O], ps[r], p) == CCW || ccw(ps[O], ps[l], p) == CW) {
        return false;
    }
    while(l + 1 < r) {
        int m = l + r >> 1;
        if(ccw(ps[O], ps[m], p) == CCW) {
            l = m;
        } else {
            r = m;
        }
    }
    if(ccw(ps[l], ps[r], p) == CW) {
        return false;
    } else {
        return true;
    }
}
void solve() {
    int n, m, q;
    cin >> n >> m >> q;
    Points A(n), B(m);
    for(int i = 0; i < n; i ++) {
        cin >> A[i];
    }
    for(int i = 0; i < m; i ++) {
        cin >> B[i];
        B[i] = -B[i];
    }
    A = Convexhell(A); n = A.size();
    B = Convexhell(B); m = B.size();
    Points C = Minkowski(A, B);
    while(q --) {
        Point query;
        cin >> query;
        if(check_in(query, C)) {
            cout << "1\n";
        } else {
            cout << "0\n";
        }
    }
}
```

## 最小圆覆盖问题

- 问题描述：平面上$n$个点, 要求找到一个半径最小的圆, 能覆盖所有的点.

算法思想: 随机增量法 (理论实践复杂度 $O(nlog\ n)$ ？但是最坏貌似还是$n^3$) 每次进入下一曾 for 的概率都小于 $\frac{3}{n}$，因此每次随机化点可以尽可能地避免最坏情况的发生。

```cpp
int n;
Points ps(n);
random_shuffle(ps.begin(), ps.end()); // 随机化
Circle res(Point(0, 0), 0);
for(int i = 0; i < n; i ++) {
    // 圆是否包含点 i
    if(CCP(res, ps[i]) == out) {
        res = Circle(ps[i], 0);
        for(int j = 0; j < i; j ++) {
            if(CCP(res, ps[j]) == out) {
                // 两点确定一个圆
                res = Circle((ps[i] + ps[j]) / 2, dis(ps[i], ps[j]) / 2);
                for(int k = 0; k < j; k ++) {
                    if(CCP(res, ps[k]) == out) {
                        // 三点确定一个圆
                        res = circumcircle(ps[i], ps[j], ps[k]);
                    }
                }
            }
        }
    }
}
```

# 动态规划

## 单调队列优化多重背包

- $O(n * m)$ 单调队列优化

```cpp
int dp[100001];
int main () {
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) {
        int v, w, l;
        cin >> v >> w >> l;
        // mod v 意义下分类
        for(int j = 0; j < v; j ++) {
            // q[0] 下标， q[1] 对答案的贡献
            deque<int> q[2];
            // 状态转移方程：dp[i][p + v * k] = dp[i - 1][p] + (y - x) * w; 
            for(int p = j, x = 1; p <= m; p += v, x ++) {
                int e = dp[p] - x * w, n = x + l;
                while(!q[1].empty() && q[1].back() <= e) {
                    q[0].pop_back(), q[1].pop_back();
                }
                q[0].push_back(n), q[1].push_back(e);
                dp[p] = q[1].front() + w * x;
                while(!q[0].empty() && q[0].front() == x) {
                    q[0].pop_front(), q[1].pop_front();
                }
            }
        }
    }
    cout << dp[m];
}
```

## 最长公共子序列

```cpp
int main (){
    int n, m;
    cin >> n >> m;
    string s1, s2;
    cin >> s1 >> s2;
    vector<vector<int> > dp(n + 1, vector<int> (m + 1));
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            dp[i][j] = dp[i - 1][j];
            dp[i][j] = max(dp[i][j], dp[i][j - 1]);
            if(s1[i - 1] == s2[j - 1]) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);
        }
    }
    cout << dp[n][m];
}
```

## 最长上升子序列

```cpp
int main () {
    int n;
    cin >> n;
    vector<int> a(n);
    for(int i = 0; i < n; i ++) cin >> a[i];
    vector<int> dp(n + 1, 0x3f3f3f3f);
    for(int i = 0; i < n; i ++) {
        auto itr = lower_bound(dp.begin(), dp.end(), a[i]);
        if(itr != dp.end()) {
            *itr = a[i];
        }
    }
    cout << lower_bound(dp.begin(), dp.end(), 1e9 + 10) - dp.begin();
}
```

# 其他

## 表达式求值

```cpp
namespace CAL {
    int expression(char*&s);  // 计算一个不带括号的表达式值
    int token(char*&s) {      // 取出一个值加入到栈中
        if(*s == '(') {
            s ++;
            int ret = expression(s);
            s ++;
            return ret;
        }
        int ret = 0;
        while('0' <= *s && *s <= '9'){
            ret = ret * 10 + *s++ - '0';
        }
        return ret % mod;
    }
    int rank(char op) {
        switch(op) {
            case '-': return 1;
            case '+': return 1;
            case '*': return 0;
        }
        return 2;
    }
    int expression(char*&s){
        stack<int> svar;
        stack<char> sop;
        svar.push(token(s));
        while(true){
            char op = *s;
            if(!op || op == ')') op = '$';
            else s++;
            while(!sop.empty() && rank(sop.top()) <= rank(op)){
                int b = svar.top();
                svar.pop();
                int a = svar.top();
                svar.pop();
                switch(sop.top()){
                    case '+':{
                        svar.push(add(a, b));
                        break;
                    }
                    case '-':{
                        svar.push(sub(a, b));
                        break;
                    }
                    case '*': {
                        svar.push(mul(a, b));
                        break;
                    }
                }
                sop.pop();
            }
            if(op == '$') break;
            svar.push(token(s));
            sop.push(op);
        }
        return svar.top();
    }
}
```

## 高精度

- 高精度加法

```cpp
//得到个位在第一位的数组
vector<int> add(vector<int> &A, vector<int> &B) {
    vector<int> C;
    int t = 0;//表示进位
    for(int i = 0;i < A.size() || i < B.size() || t; i ++) {
        if(i < A.size() ) t += A[i];
        if(i < B.size() ) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    return C;
}
```

- 高精度减法

```cpp
//要求A >= B >= 0
vector<int> sub(vector<int> &A, vector<int> &B) {
    vector<int> C;
    int t = 0;//表示借位
    for(int i = 0; i < A.size(); i ++) {
        t = A[i] - t;
        if(i < B.size() ) t -= B[i];
        C.push_back((t + 10) % 10);
        if(t < 0) t = 1;
        else t = 0;
    }
    while(C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

- 高精度乘法（高精度乘低精度）

```cpp
//要求 A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b) {
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ ) {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

- 高精度乘法（高精度乘高精度）

 ```cpp
vector<int> mul(vector<int> &A, vector<int> &B){
    vector<int>C(A.size() + B.size());
    for(int i = 0; i < A.size(); i++) {
            int t = 0;
            for(int j = 0; j < B.size(); j ++) {
                C[i +j] += A[i] * B[j] + t;
                t = C[i + j] / 10;
                C[i + j] %= 10;
            }
            C[i + B.size()] += t;
    }
    while(C.back() == 0 && C.size() > 1) C.pop_back();
    return C;
}
 ```


- 高精度除法（高精度除低精度）

```cpp
vector<int> div(vector<int> &A, int b, int &r) {
    vector<int> C;
    r = 0;
    for(int i = A.size() - 1;i >= 0;i --) {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(),C.end() );
    while(C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

## 离散化

- 一维坐标离散化

```cpp
int n;
vector<int> a(n);
vector<int> temp(n);
sort(temp.begin(), temp.end());
temp.resize(unique(temp.begin(), temp.end()) - temp.begin());
for(int i = 0; i < n; i ++) {
    a[i] = lower_bound(temp.begin(), temp.end(), a[i]) - temp.begin();
}
```

- 二维坐标离散化

无限大平面图有限等效为等价的有限图，以便做bfs或者dfs处理

原理：存储任意点的**上下左右和自己五个点的坐标**，建图.

```cpp
const int MAXN = 1e3 + 10;
int gra[MAXN * 6][MAXN * 6];
int x[MAXN], y[MAXN];
int r, c, n;
int ch (int *x, int len) {
    vector<int> xs;
    for(int i = 0; i < n; i ++) {
        for(int d = -1; d <= 1; d ++) {
            int tx = x[i] + d;
            if(tx >= 1 && tx <= len) {
                xs.push_back(tx);
            }
        }
    }
    sort(xs.begin(), xs.end());
    xs.resize(unique(xs.begin(), xs.end()) - xs.begin());
    for(int i = 0; i < n; i ++) {
        x[i] = lower_bound(xs.begin(), xs.end(), x[i]) - xs.begin();
    }
    return xs.size();
}
void solve() {
    cin >> r >> c >> n;
    for(int i = 0; i < n; i ++) {
        cin >> x[i] >> y[i];
    }
    r = ch(x, r);
    c = ch(y, c);
    for(int i = 0; i < n; i ++) {
        gra[x[i]][y[i]] = 1;
    }
    for(int i = 0; i < r; i ++) {
        for(int j = 0; j < c;j ++) {
            cout << gra[i][j] << ' ';
        }
        cout << '\n';
    }
}
```

## 区间合并

```cpp
vector<PII> merge(vector<PII> segs) {
    vector<PII> res;
    sort(segs.begin(), segs.end());
    int st = segs[0].first, ed = segs[0].second;
    for(auto x : segs) {
        if(x.first <= ed) {
            ed = max(x.second, ed);
        } else {
            res.push_back({st, ed});
            st = x.first, ed = x.second;
        }
    }
    res.push_back({st, ed});
    return res;
}
```

## 最小区间覆盖

给定 $n$ 个区间和范围 $[a, b]$，要求选择最少的区间使得 $[a, b]$ 被完全覆盖。

```cpp
int main() {
    int n, t;
    scanf("%d %d",&n, &t);
    vector<PII> v(n);
    for(int i = 0; i < n; i ++) {
        scanf("%d%d", &v[i].first, &v[i].second);
    }
    sort(v.begin(), v.end());
    int res = 0;
    int r = 0;
    for(int i = 0; r < t;) {
        int l = r + 1;
        for(int j = i; j < n; j ++) {
            if(v[j].first <= l) {
                if(v[j].second >= l) {
                    r = max(r, v[j].second);
                }
            } else {
                i = j;
                break;
            }
        }
        if(l > r) {
            printf("%d",-1);
            return 0;
        } else {
            res ++;
        }
    }
    printf("%d", res);
    return 0;
}
```

## 全排列

```cpp
// 下一组
next_permutation(p.begin(), p.end());
// 上一组
prev_permutation(p.begin(), p.end());
```

## 快读

```cpp
void read(){}
template<typename T,typename... Ts>
inline void read(T &arg,Ts&... args) {
    T x = 0, f = 1;
    char c = getchar();
    while(!isdigit(c)){if(c == '-') f = -1; c = getchar();}
    while(isdigit(c)){x = (x << 3) +(x << 1) + (c - '0');c = getchar();}
    arg = x * f;
    read(args...);
}
```